{
  Copyright 2002-2009 Michalis Kamburelis.

  This file is part of "view3dscene".

  "view3dscene" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "view3dscene" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "view3dscene"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

{ WWW page of this program, with user documentation,
  is here: [http://vrmlengine.sourceforge.net/view3dscene.php].

  Note: if you want to find out how to use Kambi VRML game engine
  in your own programs, this program's source code is not the best place
  to study. It's quite complex, using virtually every feature of our engine,
  making it all configurable from menu, and filled with a lot
  of user interface details.
  Instead you should look at simple example program in
  ../kambi_vrml_game_engine/3dmodels.gl/examples/simplest_vrml_browser.pasprogram

  Also kambi_vrml_game_engine/3dmodels/examples/many2vrml.pasprogram is
  an example how to write simple command-line converter from Collada, OBJ, 3DS
  (and all other model formats we can read) to VRML.

  This is a VRML/X3D browser, also able to load many other 3D model formats.
  Basic components are :
  - use LoadAsVRMLSequence to load any format to VRML scene.
    This converts any known (to our engine) 3D model format to VRML.
    This convertion doesn't lose anything because VRML is able to
    express everything that is implemented in other 3D formats readers.
    And we gain the simplicity of this program (we just treat everything
    as VRML scene, actually VRML animation),
    optimization (display lists optimizations,
    OpenGL renderer cache inside VRML renderer), functionality
    (like automatic normals generation based on creaseAngle).
  - render scene using TVRMLGLScene (actually TVRMLGLAnimation
    and TVRMLGLScene is inside)
  - use Navigation and TGLWindowNavigated to let user navigate
    over the scene using various navigation modes
    (Examine, Walk) and with optional gravity
  - build TVRMLTriangleOctree to allow collision detection for
    Walk navigation and to allow raytracer
  - build TVRMLShapeOctree to allow frustum culling using
    octree by TVRMLGLScene
  - use VRMLRayTracer embedded in RaytraceToWindow module to allow
    viewing raytraced image
  - allow some kind of object picking with mouse left button
    (for VRML sensors) and right button (to select for editing).
    This uses simple one-primary-ray casting.
}

program view3dscene;

{$ifdef MSWINDOWS}
  {$R windows/view3dscene.res}
{$endif MSWINDOWS}

uses KambiUtils, SysUtils, VectorMath, Boxes3d, Classes, KambiClassUtils,
  BFNT_BitstreamVeraSansMono_Bold_m15_Unit,
  ParseParametersUnit, ProgressUnit, Navigation, RaysWindow,
  KambiStringUtils, KambiFilesUtils, Math, KambiTimeUtils,
  DataErrors, KambiLog, ProgressConsole, DateUtils, Frustum,
  Images, CubeMap, DDS,
  { OpenGL related units: }
  GL, GLU, GLExt, GLWindow, GLW_Navigated, KambiGLUtils, OpenGLBmpFonts,
  GLWinMessages, ProgressGL, GLWindowRecentMenu, GLImages,
  GLAntiAliasing, GLVersionUnit, GLCubeMap,
  { VRML (and possibly OpenGL) related units: }
  VRMLFields, KambiOctree, VRMLTriangleOctree, VRMLShapeOctree,
  VRMLNodes, Object3dAsVRML, VRMLGLScene, VRMLTriangle,
  VRMLScene, VRMLRayTracer, BackgroundGL, VRMLNodesDetailOptions,
  VRMLCameraUtils, VRMLErrors, VRMLGLHeadLight, VRMLGLAnimation,
  VRMLRendererOptimization, VRMLOpenGLRenderer, VRMLShape,
  { view3dscene-specific units: }
  TextureFilters, ColorModulators, V3DSceneLights, RaytraceToWindow,
  MultiNavigators, SceneChangesUnit, BGColors, V3DSceneCamera,
  V3DSceneConfig, V3DSceneBlending, V3DSceneWarnings, V3DSceneFillMode,
  V3DSceneAntiAliasing, V3DSceneScreenShot, V3DSceneOptimization,
  V3DSceneShadows;

var
  ShowStatus: boolean = true;
  ShowBBox: boolean = true;

  ShowFrustum: boolean = false;
  ShowFrustumAlwaysVisible: boolean = false;

  OctreeDisplayWhole: boolean = false;
  { This is meaningful only if OctreeDisplayWhole = false.
    -1 means "don't display octree". }
  OctreeDisplayDepth: integer = -1;

  { ponizsze zmienne istotne tylko w trybach nawigacji ktore robia
    wykrywanie kolizji:

    When CollisionCheck = true, octree is always initialized
    (were after SceneOctreeCreate, before SceneOctreeDestroy).
    Otherwise, when CollisionCheck = false, octree *may* be available
    but doesn't have to. When setting CollisionCheck to false we do not
    immediately destroy the octree (in case user will just go back
    to CollisionCheck = true next), but it will be destroyed on next
    rebuild of octree (when we will just destroy old and not recreate new).
  }
  CollisionCheck: boolean = true;
  MenuCollisionCheck: TMenuItemChecked;

  { ustalane w Init, finalizowane w Close }
  StatusFont: TGLBitmapFont;

  RecentMenu: TGLRecentMenu;

  { These are so-called "scene global variables".
    Modified only by LoadSceneCore (and all using it Load*Scene* procedures)
    and FreeScene.
    Also note that Glw.Caption (and FPSBaseCaption) also should be modified
    only by those procedures.

    In this program's comments I often talk about "null values" of these
    variables, "null values" mean that these variables have some *defined
    but useless* values, i.e.
      SceneAnimation.Loaded = false
      SceneFileName = '' }
  { Note that only one SceneAnimation object is created and present for the whole
    lifetime of this program, i.e. when I load new scene (from "Open"
    menu item) I DO NOT free and create new SceneAnimation object.
    Instead I'm only freeing and creating underlying scenes
    (by Close / Load of TVRMLGLAnimation).
    This way I'm preserving values of all Attributes.Xxx when opening new scene
    from "Open" menu item. }
  SceneAnimation: TVRMLGLAnimation;
  SceneFilename: string;
  SceneHeadlight: TVRMLGLHeadlight;

  SelectedItem: PVRMLTriangle;
  { SelectedPoint* always lies on SelectedItem item,
    and it's meaningless when SelectedItem = nil.
    World is in world coords,
    local in local shape (SelectedItem^.State.Transform) coords. }
  SelectedPointWorld, SelectedPointLocal: TVector3Single;
  MenuSelectedOctreeStat: TMenuItem;
  MenuSelectedInfo: TMenuItem;
  MenuSelectedLightsInfo: TMenuItem;
  MenuRemoveSelectedGeometry: TMenuItem;
  MenuRemoveSelectedFace: TMenuItem;
  MenuEditMaterial: TMenu;

  SceneWarnings: TSceneWarnings;

  { This is used solely to display "WorldTime: LoadTime + %f" on status,
    to show time more helpful for the user.

    0 means that starting WorldTime was TimeBegin of the animation
    (0.0 in case of normal VRML files, usually 0.0 in case of Kanim). }
  WorldTimeAtLoad: TKamTime = 0;

  LastIsAboveTheGround: boolean;
  LastHeightAboveTheGround: Single;

var
  { When setting this, always update also WorldTime }
  AnimationTime: TKamTime = 0.0;
  AnimationTimeSpeed: TKamTime = 1.0;
  AnimationTimeSpeedWhenLoading: TKamTime = 1.0;
  AnimationTimePlaying: boolean = true;
  MenuAnimationTimePlaying: TMenuItemChecked;

  { These are set by Draw right after rendering a SceneAnimation frame. }
  LastRender_RenderedShapesCount: Cardinal;
  LastRender_VisibleShapesCount: Cardinal;

{ Helper functions -------------------------------------------------- }

procedure UpdateSelectedEnabled;
begin
  if MenuSelectedInfo <> nil then
    MenuSelectedInfo.Enabled := SelectedItem <> nil;
  if MenuSelectedOctreeStat <> nil then
    MenuSelectedOctreeStat.Enabled := SelectedItem <> nil;
  if MenuSelectedLightsInfo <> nil then
    MenuSelectedLightsInfo.Enabled := SelectedItem <> nil;
  if MenuRemoveSelectedGeometry <> nil then
    MenuRemoveSelectedGeometry.Enabled := SelectedItem <> nil;
  if MenuRemoveSelectedFace <> nil then
    MenuRemoveSelectedFace.Enabled := SelectedItem <> nil;
  if MenuEditMaterial <> nil then
    MenuEditMaterial.Enabled := SelectedItem <> nil;
end;

function SceneOctreeCollisions: TVRMLBaseTrianglesOctree;
begin
  if (SceneAnimation <> nil) and
     (SceneAnimation.ScenesCount <> 0) and
     (SceneAnimation.FirstScene.OctreeCollisions <> nil) then
    Result := SceneAnimation.FirstScene.OctreeCollisions else
    Result := nil;
end;

function SceneOctreeRendering: TVRMLShapeOctree;
begin
  if (SceneAnimation <> nil) and
     (SceneAnimation.ScenesCount <> 0) and
     (SceneAnimation.FirstScene.OctreeRendering <> nil) then
    Result := SceneAnimation.FirstScene.OctreeRendering else
    Result := nil;
end;

{ This calls SceneAnimation.PrepareRender.
  Additionally, if AllowProgess and some other conditions are met,
  this show progress of operation.

  Remember that you can call this only when gl context is already active
  (SceneAnimation.PrepareRender requires this) }
procedure PrepareRender(AllowProgress: boolean);
var
  Options: TPrepareRenderOptions;
  TG: TTransparentGroups;
begin
  AllowProgress := AllowProgress and
    (SceneAnimation.ScenesCount > 1);

  if AllowProgress then
    Progress.Init(SceneAnimation.ScenesCount, 'Preparing animation', true);
  try
    Options := [prBackground, prBoundingBox];
    TG := [tgAll];
    if ShadowsPossibleCurrently and
       ShadowsOn and
       SceneAnimation.SceneFromTime(AnimationTime).MainLightForShadowsExists then
    begin
      Options := Options + prShadowVolume;
      TG := TG + [tgOpaque, tgTransparent];
    end;

    SceneAnimation.PrepareRender(TG, Options, AllowProgress);
  finally
    if AllowProgress then
      Progress.Fini;
  end;
end;

procedure SceneOctreeCreate; forward;

procedure SetCollisionCheck(const Value: boolean;
  const NeedMenuUpdate: boolean = true);
begin
  if CollisionCheck <> Value then
  begin
    CollisionCheck := Value;
    if NeedMenuUpdate then
      MenuCollisionCheck.Checked := Value;
    if CollisionCheck and
      (SceneAnimation.FirstScene.OctreeCollisions = nil) then
      SceneOctreeCreate;
  end;
end;

function CameraKind: TVRMLCameraKind; forward;
function ViewpointNode: TVRMLViewpointNode; forward;

{ TGLWindow callbacks --------------------------------------------------------- }

procedure Init(Glwin: TGLWindow);
begin
 statusFont := TGLBitmapFont.Create(@BFNT_BitstreamVeraSansMono_Bold_m15);

 { normalize normals because we will scale our objects in Examiner navigation;
   chwilowo i tak w Scene.Render zawsze jest wlaczane glEnable(GL_NORMALIZE)
   ale to nie zawsze bedzie prawdziwe.  }
 glEnable(GL_NORMALIZE);
 glEnable(GL_DEPTH_TEST);

 { We want to be able to render any scene --- so we have to be prepared
   that fog interpolation has to be corrected for perspective. }
 glHint(GL_FOG_HINT, GL_NICEST);

 ProgressGLInterface.Window := Glw;
 Progress.UserInterface := ProgressGLInterface;

 BGColorChanged;

 ShadowsGLInit;

 AntiAliasingGLInit;
 AntiAliasingEnable;
end;

procedure Close(Glwin: TGLWindow);
begin
  if SceneAnimation <> nil then
    SceneAnimation.CloseGL;
  ShadowsGLClose;
  FreeAndNil(statusFont);
end;

procedure DrawStatus(data: Pointer);

  function OctreeDisplayToStr: string;
  begin
    if OctreeDisplayWhole then
      Result := 'whole' else
    if OctreeDisplayDepth <> -1 then
      Result := 'depth ' + IntToStr(OctreeDisplayDepth) else
      Result := 'none';
  end;

const
  BoolToStrOO: array[boolean] of string = ('OFF','ON');
  StatusInsideCol: TVector4f = (0, 0, 0, 0.7);
  StatusBorderCol: TVector4f = (0, 1, 0, 1);
  StatusTextCol  : TVector4f = (1, 1, 0, 1);
var
  strs: TStringList;

  { Describe pointing-device sensors (under the mouse, and also active
    one (if any)). }
  procedure DescribeSensors;

    function DescribeSensor(Sensor: TVRMLNode): string;
    var
      Desc: string;
      J: Integer;
    begin
      Result := '';

      if Sensor.NodeName <> '' then
        Result += Format('%s (%s)', [Sensor.NodeName, Sensor.NodeTypeName]) else
        Result += Format('%s', [Sensor.NodeTypeName]);

      if Sensor is TNodeX3DPointingDeviceSensorNode then
        Desc := TNodeX3DPointingDeviceSensorNode(Sensor).FdDescription.Value else
      if Sensor is TNodeAnchor then
      begin
        Desc := TNodeAnchor(Sensor).FdDescription.Value;
        for J := 0 to TNodeAnchor(Sensor).FdUrl.Count - 1 do
        begin
          if J = 0 then
          begin
            if Desc <> '' then Desc += ' ';
            Desc += '[';
          end else
            Desc += ', ';
          Desc += TNodeAnchor(Sensor).FdUrl.Items.Items[J];
        end;
        if TNodeAnchor(Sensor).FdUrl.Count <> 0 then
          Desc += ']';
      end else
        Desc := '';

      Desc := SForCaption(Desc);
      if Desc <> '' then
        Result += ' ' + Desc;
    end;

  var
    Sensors: TPointingDeviceSensorsList;
    I: Integer;
  begin
    Strs.Clear;

    if SceneAnimation.ScenesCount = 1 then
    begin
      if SceneAnimation.Scenes[0].PointingDeviceOverItem <> nil then
      begin
        Sensors := SceneAnimation.Scenes[0].PointingDeviceSensors;
        for I := 0 to Sensors.Count - 1 do
          if Sensors.Enabled(I) then
            Strs.Append('Over enabled sensor: ' + DescribeSensor(Sensors[I]));
      end;
      if SceneAnimation.Scenes[0].PointingDeviceActiveSensor <> nil then
        Strs.Append('Active sensor: ' +
          DescribeSensor(SceneAnimation.Scenes[0].PointingDeviceActiveSensor));
    end;

    if Strs.Count <> 0 then
    begin
      glLoadIdentity;
      glTranslatef(5, 0, 0);
      statusFont.PrintStringsBorderedRectTop(strs, 0,
        StatusInsideCol, StatusBorderCol, StatusTextCol,
        nil, 5, 1, 1, Glw.Height, 5);
    end;
  end;

  function CurrentHeightAboveTheGround: string;
  begin
    if SceneOctreeCollisions = nil then
      Result := 'no collisions' else
    if not WalkNav.Gravity then
      Result := 'no gravity' else
    if not LastIsAboveTheGround then
      Result := 'no ground beneath' else
      Result := FloatToNiceStr(LastHeightAboveTheGround);
  end;

var
  s: string;
begin
 glLoadIdentity;
 glTranslatef(5, 5, 0);

 strs := TStringList.Create;
 try
  strs.Append(Format('Navigation mode: %s', [NavigatorNames[NavigatorKind]]));

  S := Format('Collision detection: %s', [ BoolToStrOO[collisionCheck] ]);
  if SceneOctreeCollisions = nil then
    S += ' (octree resources released)';
  strs.Append(S);

  if Glw.Navigator is TWalkNavigator then
  begin
   strs.Append(Format('Camera: pos %s, dir %s, up %s',
     [ VectorToNiceStr(Glw.WalkNav.CameraPos),
       VectorToNiceStr(Glw.WalkNav.CameraDir),
       VectorToNiceStr(Glw.WalkNav.CameraUp) ]));
   strs.Append(Format('Move speed : %f, Avatar height: %f (last height above the ground: %s)',
     [ { In view3dscene, MoveHorizontalSpeed is always equal to
         MoveVerticalSpeed (as they change when user uses Input_MoveSpeedInc/Dec).
         So it's enough to show just MoveHorizontalSpeed. }
       Glw.WalkNav.MoveHorizontalSpeed,
       Glw.WalkNav.CameraPreferredHeight,
       CurrentHeightAboveTheGround ]));
  end else
  begin
   strs.Append(Format('Rotation quat : %s, Move : %s, Scale : %f',
     [ VectorToNiceStr(Glw.ExamineNav.Rotations.Vector4),
       VectorToNiceStr(Glw.ExamineNav.MoveAmount),
       Glw.ExamineNav.ScaleFactor ]));
  end;

  strs.Append(Format('Camera Kind : %s, Octree display : %s',
    [ VRMLCameraKindToStr[CameraKind],
      OctreeDisplayToStr ]));

  if SceneLightsCount = 0 then
   s := '(useless, scene has no lights)' else
   s := BoolToStrOO[SceneAnimation.Attributes.UseLights];
  strs.Append(Format('Use scene lights: %s', [s]));

  { Note: there's no sense in showing here Glw.FpsRealTime,
    since it would force me to constantly render new frames just
    to show constantly changing Glw.FpsRealTime ...
    this makes no sense, of course.
    I can sensibly show here only Glw.FpsFrameTime.
    User will be able to see Glw.FpsRealTime only on window's Caption. }
  strs.Append(Format('Rendered Shapes : %d of %d. FPS : %f',
    [ LastRender_RenderedShapesCount,
      LastRender_VisibleShapesCount,
      Glw.Fps.FrameTime ]));

  if WorldTimeAtLoad = 0.0 then
    S := Format('World time: %f', [AnimationTime]) else
    S := Format('World time: load time + %f = %f',
      [AnimationTime - WorldTimeAtLoad, AnimationTime]);
  if not AnimationTimePlaying then
    S += ' (paused)';
  strs.Append(S);

  {statusFont.printStringsBorderedRect(strs, 0, Brown4f, Yellow4f, Black4f,
    nil, 5, 1, 1);}

  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_BLEND);

    statusFont.printStringsBorderedRect(strs, 0,
      StatusInsideCol, StatusBorderCol, StatusTextCol,
      nil, 5, 1, 1);

    DescribeSensors;

  glDisable(GL_BLEND);
 finally strs.Free end;
end;

procedure BeforeDraw(Glwin: TGLWindow);
begin
  PrepareRender(false);
end;

procedure Draw3d(const ForCubeMap: boolean;
  const CameraMatrix, CameraRotationOnlyMatrix: TMatrix4Single;
  const Frustum: TFrustum);

  procedure DisplayOctreeDepth(octreeDisplayDepth: integer);

    procedure Doit(octreenode: TOctreeNode);
    var
      b0, b1, b2: boolean;
    begin
      with octreenode do
        if Depth = octreeDisplayDepth then
        begin
          if not (IsLeaf and (ItemsCount = 0)) then
            glDrawBox3dWire(Box);
        end else
        if not IsLeaf then
        begin
          for b0 := false to true do
            for b1 := false to true do
              for b2 := false to true do
                Doit(TreeSubNodes[b0, b1, b2]);
        end;
    end;

  var
    SI: TVRMLShapeTreeIterator;
  begin
    { Octree is not always ready, as it's recalculation during animations
      may hurt. Also, Draw may be called in various situations even when Scene
      is not really ready (e.g. when showing errors after scene loading).
      Also, octrees for particular shapes are not necessarily
      created, since some shapes may be not collidable.
      So we have to carefully check here whether appropriate things
      are initialized. }

    if (SceneAnimation <> nil) and
       (SceneAnimation.ScenesCount <> 0) then
    begin
      SI := TVRMLShapeTreeIterator.Create(SceneAnimation.FirstScene.Shapes, true);
      try
        while SI.GetNext do
          if SI.Current.OctreeTriangles <> nil then
          begin
            glPushMatrix;
              glMultMatrix(SI.Current.State.Transform);
              Doit(SI.Current.OctreeTriangles.TreeRoot);
            glPopMatrix;
          end;
      finally FreeAndNil(SI) end;
    end;
  end;

  procedure DisplayOctreeWhole;

    procedure Doit(OctreeNode: TOctreeNode);
    var
      b0, b1, b2: boolean;
    begin
      with OctreeNode do
      begin
        if not (IsLeaf and (ItemsCount = 0)) then
          glDrawBox3dWire(Box);

        if not IsLeaf then
        begin
          for b0 := false to true do
            for b1 := false to true do
              for b2 := false to true do
                Doit(TreeSubNodes[b0, b1, b2]);
        end;
      end;
    end;

  var
    SI: TVRMLShapeTreeIterator;
  begin
    { Octree is not always ready, as it's recalculation during animations
      may hurt. Also, Draw may be called in various situations even when Scene
      is not really ready (e.g. when showing errors after scene loading).
      Also, octrees for particular shapes are not necessarily
      created, since some shapes may be not collidable.
      So we have to carefully check here whether appropriate things
      are initialized. }

    if (SceneAnimation <> nil) and
       (SceneAnimation.ScenesCount <> 0) then
    begin
      SI := TVRMLShapeTreeIterator.Create(SceneAnimation.FirstScene.Shapes, true);
      try
        while SI.GetNext do
          if SI.Current.OctreeTriangles <> nil then
          begin
            glPushMatrix;
              glMultMatrix(SI.Current.State.Transform);
              Doit(SI.Current.OctreeTriangles.TreeRoot);
            glPopMatrix;
          end;
      finally FreeAndNil(SI) end;
    end;
  end;

  procedure DrawFrustum(AlwaysVisible: boolean);
  var
    FrustumPoints: TFrustumPointsDouble;
  begin
    if AlwaysVisible then
    begin
      glPushAttrib(GL_ENABLE_BIT);
      glDisable(GL_DEPTH_TEST);
    end;
    try
      WalkNav.Frustum.CalculatePoints(FrustumPoints);
      glColor3f(1, 1, 1);
      glEnableClientState(GL_VERTEX_ARRAY);
        glVertexPointer(4, GL_DOUBLE, 0, @FrustumPoints);
        glDrawElements(GL_LINES, 12 * 2, GL_UNSIGNED_INT,
          @FrustumPointsLinesIndexes);
      glDisableClientState(GL_VERTEX_ARRAY);
    finally
      if AlwaysVisible then glPopAttrib;
    end;
  end;

var
  Scene: TVRMLGLScene;

  procedure ClearAndRenderBackground;
  var
    BackgroundWireframe: boolean;
    ClearBuffers: TGLbitfield;
  begin
    ClearBuffers := GL_DEPTH_BUFFER_BIT;
    if ShadowsPossibleCurrently and
       ShadowsOn and
       Scene.MainLightForShadowsExists then
      ClearBuffers := ClearBuffers or GL_STENCIL_BUFFER_BIT;

    glClear(ClearBuffers);

    if Scene.Background <> nil then
    begin
      { jezeli BackgroundWireframe i mamy Background to rysujemy
        Backgr w trybie wireframe (czyszczac
        poprzednio teren przez glClear(GL_COLOR_BUFFER_BIT)) - nawet jezeli nie jest
        zdefiniowane czy Backgr.Render nie bedzie takze uzywalo glClear do wyczyszczenia
        ekranu. W rezultacie wynik renderowania jest nieco niezdefiniowany (zalezy
        od tego jak bedzie dzialac Backgr.Render - czy ekran bedzie pokazywal szkielet
        jakiejs kuli i za nim kolor BGColor czy tez moze bedzie wypelniony kolorem
        Backgr.FdSkyColors[0]) ale to nic - to co widac w trybie wireframe nigdy nie mialo
        byc jasno zdefiniowane i zawsze bylo w tym widac sporo implementation-specific
        rzeczy.

        Nie zdecydowalem sie na prostsze rozwiazanie (i dajace lepiej zdefiniowany
        rezultat renderowania) aby zignorowac Wireframe przy rysowaniu Backgr.
        Zrobilem to dlatego ze ogladanie nieba w trybie wireframe jest pomocne -
        czasem wygodnie jest wiedziec gdzie przebiegaja krawedzie szescianu nieba
        aby zobaczyc czy niebo tam dobrze pasuje. Jest to tez pomocne mi abym mogl
        sprawdzic czy BackgroundGL dziala dobrze.
      }
      BackgroundWireframe := FillModes[FillMode].BackgroundWireframe;
      if BackgroundWireframe then
      begin
        glClear(GL_COLOR_BUFFER_BIT);
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
      end;
      try
        glLoadMatrix(CameraRotationOnlyMatrix);
        Scene.Background.Render;
      finally
        if BackgroundWireframe then glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
      end;
    end else
      glClear(GL_COLOR_BUFFER_BIT);
  end;

begin
 Scene := SceneAnimation.SceneFromTime(AnimationTime);
 ClearAndRenderBackground;

 glLoadMatrix(CameraMatrix);
 VRMLOpenGLRenderer.CameraMatrix := CameraMatrix;

 { Set properties of headlight. Actual enabled state of headlight will be
   set later by BeginRenderSceneWithLights. }
 if (SceneHeadlight <> nil) then
   SceneHeadlight.Render(0, false, not ForCubeMap,
     { TODO: this isn't nice. We should just pass here current
       Glw.Navigator, so that headlight in Examine mode would work too.
       But we can't, since current TExamineNavigator doesn't provide
       CameraPos, CameraDir... }
     WalkNav);

 if OctreeDisplayWhole then
 begin
   glColorv(Yellow3Single);
   DisplayOctreeWhole;
 end else
 if OctreeDisplayDepth >= 0 then
 begin
   glColorv(Yellow3Single);
   DisplayOctreeDepth(OctreeDisplayDepth);
 end;

 if showBBox and (not MakingScreenShot) and (not ForCubeMap) then
 begin
   { Display current bounding box only if there's a chance that it's
     different than whole BoundingBoxSum --- this requires that animation
     has at least two frames. }
   if SceneAnimation.ScenesCount > 1 then
   begin
     glColorv(Red3Single);
     if not IsEmptyBox3d(Scene.BoundingBox) then
       glDrawBox3dWire(Scene.BoundingBox);
   end;

   glColorv(Green3Single);
   if not IsEmptyBox3d(SceneAnimation.BoundingBoxSum) then
     glDrawBox3dWire(SceneAnimation.BoundingBoxSum);
 end;

 { In methods other than bmGLSLAll, setting Scene.BumpMappingLightPosition
   may be costly operation. So don't do this. }
 if Scene.BumpMappingMethod in bmGLSLAll then
   Scene.BumpMappingLightPosition := WalkNav.CameraPos;

 BeginRenderSceneWithLights(SceneAnimation);

   if FillMode = fmSilhouetteBorderEdges then
     RenderSilhouetteBorderEdges(Vector4Single(WalkNav.CameraPos, 1), Scene) else
   begin
     { Scene.RenderFrustum (below, or inside ShadowsRender)
       will automatically use octree, if available.
       Note that octree may be not available (for animations,
       OctreeRendering is constructed only for the 1st scene.
       Also, generation of octree may be turned off for
       speed purposes.) }

     if ShadowsPossibleCurrently and
        ShadowsOn and
        Scene.MainLightForShadowsExists then
       ShadowsRender(Scene, Frustum, Scene.MainLightForShadows) else
       Scene.RenderFrustum(Frustum, tgAll);

     LastRender_RenderedShapesCount := Scene.LastRender_RenderedShapesCount;
     LastRender_VisibleShapesCount  := Scene.LastRender_VisibleShapesCount;
   end;

 EndRenderSceneWithLights;

 { Note that there is no sense in showing viewing frustum in
   NavigatorKind <> nkExamine, since viewing frustum should
   be never visible then (or should be just at the exact borders
   or visibility, so it's actually unspecified whether OpenGL would
   show it or not). }
 if ShowFrustum and (NavigatorKind = nkExamine) then
  DrawFrustum(ShowFrustumAlwaysVisible);

 if SelectedItem <> nil then
 begin
   if not GLVersion.BuggyPointSetAttrib then
     glPushAttrib(GL_ENABLE_BIT or GL_LINE_BIT or GL_POINT_BIT) else
     glPushAttrib(GL_ENABLE_BIT or GL_LINE_BIT);

     glDisable(GL_DEPTH_TEST); { saved by GL_ENABLE_BIT }
     glColorv(White3Single);

     glLineWidth(3.0); { saved by GL_LINE_BIT }
     glBegin(GL_LINE_LOOP);
       glVertexv(SelectedItem^.World.Triangle[0]);
       glVertexv(SelectedItem^.World.Triangle[1]);
       glVertexv(SelectedItem^.World.Triangle[2]);
     glEnd;

     glPointSize(5.0); { saved by GL_POINT_BIT }
     glBegin(GL_POINTS);
       glVertexv(SelectedPointWorld);
     glEnd;
   glPopAttrib;
 end;
end;

procedure Draw(Glwin: TGLWindow);
begin
 SceneAnimation.FirstScene.UpdateGeneratedTextures(@Draw3d,
   SceneAnimation.WalkProjectionNear, SceneAnimation.WalkProjectionFar,
   true, 0, 0);
 glViewport(0, 0, Glwin.Width, Glwin.Height);

 Draw3d(false, Glw.Navigator.Matrix, Glw.Navigator.RotationOnlyMatrix,
   Glw.Navigator.Frustum);

 if ShowStatus and (not MakingScreenShot) then
 begin
  { Note that DrawStatus changes current modelview matrix,
    so you want to always leave drawing status at the end of this Draw
    procedure. }
  glPushAttrib(GL_ENABLE_BIT);
    glDisable(GL_DEPTH_TEST);
    glProjectionPushPopOrtho2D(@DrawStatus, nil, 0, Glwin.Width, 0, Glwin.Height);
  glPopAttrib;
 end;
end;

var
  AngleOfViewX, AngleOfViewY: Single;

procedure Resize(Glwin: TGLWindow);
begin
  SceneAnimation.GLProjection(
    Glw.Navigator, SceneAnimation.BoundingBoxSum,
    Glwin.Width, Glwin.Height, AngleOfViewX, AngleOfViewY,
    ShadowsPossibleCurrently);

  { GLProjection set only current Navigator's ProjectionMatrix,
    we want to pass ProjectionMatrix to all navigators. }
  SetProjectionMatrix(Glw.Navigator.ProjectionMatrix);
end;

const
  SOnlyInWalker = 'You must be in ''Walk'' navigation mode '+
    'to use this function.';

  SOnlyWhenOctreeAvailable = 'This is not possible when octree is not generated. Turn on "Navigation -> Collision Detection" to make it available.';

procedure MouseDown(Glwin: TGLWindow; btn: TMouseButton);
var
  Ray0, RayVector: TVector3Single;
begin
  { In Examiner mode, mouse clicks start dragging, so don't do
    anything here (not even a warning about SOnlyInWalker,
    since it would only interfere with navigation). }

  if Glw.Navigator is TWalkNavigator then
  begin
    if btn = mbLeft then
    begin
      if SceneAnimation.ScenesCount = 1 { ProcessEvents = true } then
      begin
        SceneAnimation.Scenes[0].PointingDeviceActive := true;
        { Our status text displays current sensors, so we have to redisplay. }
        Glwin.PostRedisplay;
      end;
    end else
    if btn = mbRight then
    begin
      if SceneOctreeCollisions = nil then
      begin
        MessageOK(Glwin, SOnlyWhenOctreeAvailable, taLeft);
        Exit;
      end;

      Glw.MousePickedRay(AngleOfViewX, AngleOfViewY, Ray0, RayVector);

      {TODO: SceneOctreeCollisions.DirectCollisionTestsCounter := 0;}

      SelectedItem := SceneOctreeCollisions.RayCollision(
        SelectedPointWorld, Ray0, RayVector, true, nil, false, nil);

      { calculate SelectedPointLocal }
      if SelectedItem <> nil then
      begin
        try
          SelectedPointLocal := MatrixMultPoint(
            SelectedItem^.State.InvertedTransform, SelectedPointWorld);
        except
          on ETransformedResultInvalid do
            SelectedItem := nil;
        end;
      end;

      { DirectCollisionTestsCounter is not recorded,
        so I may write it now on console in case it will be useful.
        For now it's commented out --- not interesting to typical user.
      Writeln(Format('%d tests for collisions between ray ' +
        'and triangles were needed to learn this.',
        [ SceneOctreeCollisions.DirectCollisionTestsCounter ])); }

      UpdateSelectedEnabled;

      Glw.PostRedisplay;
    end;
  end;
end;

procedure MouseUp(Glwin: TGLWindow; btn: TMouseButton);
begin
  if Glw.Navigator is TWalkNavigator then
  begin
    if btn = mbLeft then
    begin
      if SceneAnimation.ScenesCount = 1 { ProcessEvents = true } then
      begin
        SceneAnimation.Scenes[0].PointingDeviceActive := false;
        { Our status text displays current sensors, so we have to redisplay. }
        Glwin.PostRedisplay;
      end;
    end;
  end;
end;

procedure MouseMove(Glwin: TGLWindow; NewX, NewY: Integer);
var
  Ray0, RayVector: TVector3Single;
  OverPoint: TVector3Single;
  Item: PVRMLTriangle;

  function SensorsCount: Cardinal;
  begin
    if SceneAnimation.Scenes[0].PointingDeviceSensors <> nil then
      Result := SceneAnimation.Scenes[0].PointingDeviceSensors.EnabledCount else
      Result := 0;
    if SceneAnimation.Scenes[0].PointingDeviceActiveSensor <> nil then
      Inc(Result);
  end;

var
  OldSensorsCount, NewSensorsCount: Cardinal;
begin
  if (SceneAnimation.ScenesCount = 1 { ProcessEvents = true }) and
     (Glw.Navigator is TWalkNavigator) and
     (SceneOctreeCollisions <> nil) then
  begin
    OldSensorsCount := SensorsCount;

    Glw.Ray(NewX, NewY, AngleOfViewX, AngleOfViewY, Ray0, RayVector);

    Item := SceneOctreeCollisions.RayCollision(
      OverPoint, Ray0, RayVector, true, nil, false, nil);

    SceneAnimation.Scenes[0].PointingDeviceMove(OverPoint, Item);

    NewSensorsCount := SensorsCount;

    { I want to keep assertion that Glwin.CursorNonMouseLook = gcHand when
      we're over or keeping active some pointing-device sensors. }
    if NewSensorsCount <> 0 then
      Glw.CursorNonMouseLook := gcHand else
      Glw.CursorNonMouseLook := gcDefault;

    if (OldSensorsCount <> 0) or
       (NewSensorsCount <> 0) then
      { Our status text displays current sensors, so we have to redisplay. }
      Glwin.PostRedisplay;
  end;
end;

procedure KeyDown(Glwin: TGLWindow; Key: TKey; C: char);
begin
  if SceneAnimation.ScenesCount = 1 then
    SceneAnimation.Scenes[0].KeyDown(Key, C, @Glwin.KeysDown);
end;

procedure KeyUp(Glwin: TGLWindow; Key: TKey; C: char);
begin
  if SceneAnimation.ScenesCount = 1 then
    SceneAnimation.Scenes[0].KeyUp(Key, C);
end;

procedure Idle(Glwin: TGLWindow);
var
  OldAnimationTime, TimeIncrease: TKamTime;
begin
  { Ignore Idle calls when IdleSpeed is precisely zero
    (this may happen, and is good, see TGLWindow.IgnoreNextIdleSpeed).
    In this case, TimeIncrease will be zero so the whole code
    will not do anything anyway. }

  if AnimationTimePlaying and (Glwin.Fps.IdleSpeed <> 0) then
  begin
    OldAnimationTime := AnimationTime;
    TimeIncrease := AnimationTimeSpeed * Glwin.Fps.IdleSpeed;

    AnimationTime += TimeIncrease;
    if SceneAnimation.ScenesCount = 1 then
      SceneAnimation.Scenes[0].IncreaseWorldTime(TimeIncrease);

    { Call PostRedisplay only if the displayed animation frame actually changed.
      This way, we avoid wasting CPU cycles if the loaded scene is actually
      still, or if the animation stopped running. }
    if (SceneAnimation.SceneFromTime(OldAnimationTime) <>
        SceneAnimation.SceneFromTime(AnimationTime)) then
      Glwin.PostRedisplay;
  end;
end;

{ TWalkNavigator collision detection using SceneOctreeCollisions --------------- }

type
  THelper = class
    class function MoveAllowed(Navigator: TWalkNavigator;
      const ProposedNewPos: TVector3Single; out NewPos: TVector3Single;
      const BecauseOfGravity: boolean): boolean;

    class procedure GetCameraHeight(Navigator: TWalkNavigator;
      out IsAboveTheGround: boolean; out SqrHeightAboveTheGround: Single);

    class procedure OpenRecent(const FileName: string);

    class procedure GeometryChanged(Scene: TVRMLScene;
      const SomeLocalGeometryChanged: boolean);
    class procedure PostRedisplay(Scene: TVRMLScene);

    class procedure BoundViewpointChanged(Scene: TVRMLScene);
    class procedure ViewpointsChanged(Scene: TVRMLScene);
    class procedure BoundViewpointVectorsChanged(Scene: TVRMLScene);

    class procedure WalkerMatrixChanged(Navigator: TNavigator);
  end;

var
  Helper: THelper;

class function THelper.MoveAllowed(Navigator: TWalkNavigator;
  const ProposedNewPos: TVector3Single; out NewPos: TVector3Single;
  const BecauseOfGravity: boolean): boolean;
begin
  if CollisionCheck then
  begin
    {TODO SceneOctreeCollisions.DirectCollisionTestsCounter := 0;}
    Result := SceneOctreeCollisions.MoveAllowed(
      Navigator.CameraPos, ProposedNewPos, NewPos, Navigator.CameraRadius);
    {tests:
     Writeln('Octree efficiency : ',SceneOctreeCollisions.DirectCollisionTestsCounter,
       ' direct tests with single triangles were needed to know that move is'
       +BoolToStrNNN[result]+'allowed');
    }
  end else
  begin
    Result := true;
    NewPos := ProposedNewPos;
  end;

  if Result and BecauseOfGravity then
    Result := SimpleKeepAboveMinPlane(NewPos, SceneAnimation.BoundingBoxSum,
      Navigator.GravityUp);
end;

class procedure THelper.GetCameraHeight(Navigator: TWalkNavigator;
  out IsAboveTheGround: boolean; out SqrHeightAboveTheGround: Single);
var
  GroundItem: PVRMLTriangle;
begin
  if SceneOctreeCollisions <> nil then
  begin
    SceneOctreeCollisions.GetCameraHeight(
      TWalkNavigator(Navigator).CameraPos,
      TWalkNavigator(Navigator).GravityUp,
      IsAboveTheGround, SqrHeightAboveTheGround, GroundItem,
      nil, nil);
    LastIsAboveTheGround := IsAboveTheGround;
    if LastIsAboveTheGround then
      LastHeightAboveTheGround := Sqrt(SqrHeightAboveTheGround);
  end else
  begin
    IsAboveTheGround := false;
  end;
end;

{ Setting viewpoint ---------------------------------------------------------- }

function NavigationNode: TNodeNavigationInfo;
begin
  if SceneAnimation.Loaded then
    Result := SceneAnimation.Scenes[0].NavigationInfoStack.Top as
      TNodeNavigationInfo else
    Result := nil;
end;

function ViewpointNode: TVRMLViewpointNode;
begin
  if SceneAnimation.Loaded then
    Result := SceneAnimation.Scenes[0].ViewpointStack.Top as
      TVRMLViewpointNode else
    Result := nil;
end;

function CameraKind: TVRMLCameraKind;
var
  Viewpoint: TVRMLViewpointNode;
begin
  Viewpoint := ViewpointNode;
  if Viewpoint <> nil then
    Result := Viewpoint.CameraKind else
    Result := ckPerspective;
end;

{ This directly sets navigator properties, without looking at
  current ViewpointNode state. It may be used to initialize
  navigator to some state that doesn't correspond to any existing
  viewpoint, or as a basis for UpdateViewpointNode.

  This takes into account NavigationNode, that is currently bound
  NavigationInfo node.

  Besides initializing navigator by WalkNav.Init, it also
  takes care to initialize MoveHorizontal/VerticalSpeed.

  Note that the length of InitialCameraDir doesn't matter. }
procedure SetViewpointCore(
  const InitialCameraPos: TVector3Single;
  InitialCameraDir: TVector3Single;
  const InitialCameraUp: TVector3Single;
  const GravityUp: TVector3Single);
begin
  { Change InitialCameraDir length, to adjust speed.
    Also set MoveHorizontal/VerticalSpeed. }

  if NavigationNode = nil then
  begin
    { Since we don't have NavigationNode.speed, we just calculate some
      speed that should "feel sensible". We base it on CameraRadius.
      CameraRadius in turn was calculated based on
      Box3dAvgSize(SceneAnimation.BoundingBoxSum). }
    VectorAdjustToLengthTo1st(InitialCameraDir, WalkNav.CameraRadius * 0.8);
    WalkNav.MoveHorizontalSpeed := 1;
    WalkNav.MoveVerticalSpeed := 1;
  end else
  if NavigationNode.FdSpeed.Value = 0 then
  begin
    { Then user is not allowed to move at all.

      InitialCameraDir must be non-zero (we normalize it just to satisfy
      requirement that "length of InitialCameraDir doesn't matter" here,
      in case user will later increase move speed by menu anyway.

      So we do this is by setting MoveHorizontal/VerticalSpeed to zero.
      This is also the reason why other SetViewpointCore must change
      MoveHorizontal/VerticalSpeed to something different than zero
      (otherwise, user would be stuck with speed = 0). }
    NormalizeTo1st(InitialCameraDir);
    WalkNav.MoveHorizontalSpeed := 0;
    WalkNav.MoveVerticalSpeed := 0;
  end else
  begin
    { view3dscene versions (<= 2.2.1) handled NavigationInfo.speed badly.
      They set InitialCameraDir length to
        CameraRadius * 0.4 * NavigationNode.FdSpeed.Value
      Effectively, speed per second was
        CameraRadius * 0.4 * NavigationNode.FdSpeed.Value * 50 / second
      If your VRML models were adjusted to this view3dscene broken handling,
      you should fix NavigationInfo.speed to value below to get the same speed
      in newer view3dscene versions :
    Writeln('Fix NavigationInfo.speed to ',
      FloatToRawStr(CameraRadius * 0.4 * NavigationNode.FdSpeed.Value * 50));
    }

    VectorAdjustToLengthTo1st(InitialCameraDir, NavigationNode.FdSpeed.Value / 50.0);
    WalkNav.MoveHorizontalSpeed := 1;
    WalkNav.MoveVerticalSpeed := 1;
  end;

  WalkNav.Init(InitialCameraPos, InitialCameraDir, InitialCameraUp,
    GravityUp, WalkNav.CameraPreferredHeight, WalkNav.CameraRadius);

  if not Glw.Closed then
  begin
    Glw.EventResize;
    Glw.PostRedisplay;
  end;
end;

{ Call this when ViewpointNode (currently bound viewpoint node)
  changed (possibly to/from nil) and we have to go to this viewpoint.

  When it's nil, we'll go to some default position.

  This does update the ViewpointsList menu.

  This doesn't call set_bind event for this viewpoint --- the idea
  is that viewpoint changed for example because something already
  did set_bind. If you want to just bind the viewpoint, then
  don't use this procedure --- instead send set_bind = true event
  to given viewpoint, and this will indirectly call this procedure.

  Uses WalkNav.CameraRadius, NavigationNode, so make sure these are already
  set as needed }
procedure UpdateViewpointNode;
var
  CameraPos: TVector3Single;
  CameraDir: TVector3Single;
  CameraUp: TVector3Single;
  GravityUp: TVector3Single;
  V: TVRMLViewpointNode;
begin
  V := ViewpointNode;
  if V <> nil then
  begin
    V.GetCameraVectors(CameraPos, CameraDir, CameraUp, GravityUp);
  end else
  begin
    CameraPos := StdVRMLCamPos[1];
    CameraDir := StdVRMLCamDir;
    CameraUp := StdVRMLCamUp;
    GravityUp := StdVRMLGravityUp;
  end;

  ViewpointsList.BoundViewpoint := V;

  SetViewpointCore(CameraPos, CameraDir, CameraUp, GravityUp);
end;

class procedure THelper.BoundViewpointChanged(Scene: TVRMLScene);
begin
  UpdateViewpointNode;
end;

class procedure THelper.ViewpointsChanged(Scene: TVRMLScene);
begin
  ViewpointsList.Recalculate(Scene);
end;

class procedure THelper.WalkerMatrixChanged(Navigator: TNavigator);
begin
  if SceneAnimation.ScenesCount = 1 then
    SceneAnimation.Scenes[0].ViewerChanged(
      (Navigator as TWalkNavigator).CameraPos,
      (Navigator as TWalkNavigator).CameraDir,
      (Navigator as TWalkNavigator).CameraUp);
  Glw.PostRedisplay;
end;

class procedure THelper.BoundViewpointVectorsChanged(Scene: TVRMLScene);
var
  CameraPos: TVector3Single;
  CameraDir: TVector3Single;
  CameraUp: TVector3Single;
  GravityUp: TVector3Single;
begin
  Assert(ViewpointNode <> nil);

  ViewpointNode.GetCameraVectors(CameraPos, CameraDir, CameraUp, GravityUp);

  { keep InitialCameraDir length the same }
  VectorAdjustToLengthTo1st(CameraDir, VectorLen(WalkNav.InitialCameraDir));

  WalkNav.SetInitialCameraLookDir(CameraPos, CameraDir, CameraUp, true);

  { TODO:
    - GravityUp is not passed
  }

  { PostRedisplay will be automatically called by SetInitialCameraLookDir,
    as matrix changed. }
end;

{ Scene operations ---------------------------------------------------------- }

var
  { This is set to non-nil by CreateMainMenu.
    It is used there and it is also used from LoadSceneCore, since
    loading a scene may change some values (like HeadLight, Gravity etc.)
    so we have to update MenuHeadlight.Checked (and other menu's) state. }
  MenuHeadlight, MenuGravity, MenuIgnoreAllInputs: TMenuItemChecked;
  MenuPreferGravityUpForRotations: TMenuItemChecked;
  MenuPreferGravityUpForMoving: TMenuItemChecked;
  MenuReopen: TMenuItem;

  DebugLogVRMLChanges: boolean = false;

procedure DoVRMLWarning(const WarningType: TVRMLWarningType; const s: string);
begin
  { Write to ErrOutput, not normal Output, since when --write-to-vrml was used,
    we write to output VRML contents. }
  Writeln(ErrOutput, ProgramName + ': VRML Warning: ' + S);
  SceneWarnings.Add(S);
end;

procedure DoDataWarning(const s: string);
begin
  { Write to ErrOutput, not normal Output, since when --write-to-vrml was used,
    we write to output VRML contents. }
  Writeln(ErrOutput, ProgramName + ': Data Warning: ' + S);
  SceneWarnings.Add(S);
end;

procedure SceneOctreeCreate;
var
  OldDraw, OldBeforeDraw: TDrawFunc;
begin
  { Do not create octrees when CollisionCheck = false. This makes
    setting to CollisionCheck an optimization: octree doesn't have to
    be recomputed when animation frame changes, or new scene is loaded etc. }

  if CollisionCheck then
  begin
    { Beware: constructing octrees will cause progress drawing,
      and progress drawing may cause FlushRedisplay,
      and FlushRedisplay may cause OnDraw and OnBeforeDraw to be called.
      That's why we simply turn normal Draw/BeforeDraw temporarily off. }
    OldDraw := Glw.OnDraw;
    OldBeforeDraw := Glw.OnBeforeDraw;
    Glw.OnDraw := nil;
    Glw.OnBeforeDraw := nil;
    try
      { For now we construct and store octrees only for the 1st animation frame. }

      SceneAnimation.FirstScene.TriangleOctreeProgressTitle := 'Building triangle octree';
      SceneAnimation.FirstScene.ShapeOctreeProgressTitle := 'Building Shape octree';
      SceneAnimation.FirstScene.Spatial := [ssRendering, ssDynamicCollisions];
    finally
      Glw.OnDraw := OldDraw;
      Glw.OnBeforeDraw := OldBeforeDraw;
    end;
  end;
end;

procedure SceneOctreeFree;
begin
  if SceneAnimation.ScenesCount <> 0 then
  begin
    { Since we destroy our PVRMLTriangles, make sure SceneAnimation.FirstScene
      doesn't hold a reference to it. }
    SceneAnimation.FirstScene.PointingDeviceClear;
    Glw.CursorNonMouseLook := gcDefault;

    SceneAnimation.FirstScene.Spatial := [];
  end;
end;

procedure Unselect;
begin
  SelectedItem := nil;
  UpdateSelectedEnabled;
end;

procedure ResetWorldTime(const NewValue: TKamTime);
begin
  { Ignored when SceneAnimation.ScenesCount <> 1, as ProcessEvents
    is always false then and WorldTime wouldn't have much sense anyway. }
  if SceneAnimation.ScenesCount = 1 then
    SceneAnimation.Scenes[0].ResetWorldTime(NewValue);
end;

{ Frees (and sets to some null values) "scene global variables".

  Note about OpenGL context: remember that changing calling Close
  on SceneAnimation also calls CloseGL  that closes all connections
  of Scene to OpenGL context. This means that:
  1) SceneAnimation must not be Loaded, or Scene must not have any
     connections with OpenGL context (like e.g. after calling
     SceneAnimation.CloseGL)
  2) or you must call FreeScene in the same OpenGL context that the
     SceneAnimation is connected to. }
procedure FreeScene;
begin
  SceneOctreeFree;

  SceneAnimation.Close;

  ViewpointsList.Recalculate(nil);

  SceneFileName := '';

  if MenuReopen <> nil then
    MenuReopen.Enabled := false;

  Unselect;

  FreeAndNil(SceneHeadlight);
end;

procedure LoadClearScene; forward;

{ Calls FreeScene and then inits "scene global variables".
  Pass here ACameraRadius = 0.0 to say that CameraRadius should be
  somehow calculated (guessed) based on loaded Scene data.

  Camera settings for scene are inited from VRML defaults and
  from camera node in scene.

  Exceptions: if this function will raise any exception you should assume
  that scene loading failed for some reason and "scene global variables"
  are set to their "null values". I.e. everything is in a "clean" state
  like after FreeScene.

  This procedure does not really open any file
  (so ASceneFileName need not be a name of existing file,
  in fact it does not need to even be a valid filename).
  Instead in uses already created RootNode to init
  "scene global variables".

  Note that all RootNodes[] will be owned by Scene.
  So do not Free RootNodes[] items after using this procedure
  (still, you should use RootNodes list itself).

  Note that this may change the value of Times list.

  Note that there is one "scene global variable" that will
  not be completely handled by this procedure:
  SceneWarnings. During this procedure some VRML warnings may
  occur and be appended to SceneWarnings. You have to take care
  about the rest of issues with the SceneWarnings, like clearing
  them before calling LoadSceneCore.

  ASceneFileName is not const parameter, to allow you to pass
  SceneFileName as ASceneFileName. If ASceneFileName would be const
  we would have problem, because FreeScene modifies SceneFileName
  global variable, and this would change ASceneFileName value
  (actually, making it possibly totally invalid pointer,
  pointing at some other place of memory). That's always the
  problem with passing pointers to global variables
  (ASceneFileName is a pointer) as local vars. }
procedure LoadSceneCore(
  RootNodes: TVRMLNodesList;
  ATimes: TDynSingleArray;
  ScenesPerTime: Cardinal;
  NewOptimization: TGLRendererOptimization;
  const EqualityEpsilon: Single;
  TimeLoop, TimeBackwards: boolean;

  ASceneFileName: string;
  const SceneChanges: TSceneChanges; const ACameraRadius: Single;
  JumpToInitialViewpoint: boolean);

  procedure ScaleAll(A: TDynSingleArray; const Value: Single);
  var
    I: Integer;
  begin
    for I := 0 to A.High do
      A.Items[I] *= Value;
  end;

  { Set NavigatorKind and related navigator properties, based on
    NavigationNode.FdType }
  procedure SetNavigationType;

    procedure SetExamineNavigationType;
    begin
      SetNavigatorKind(Glw, nkExamine);

      { Set also WalkNav properties to something predictable
        (*not* dependent on previous values, as this would be rather
        confusing to user (new model should just start with new settings).
        In particular, IgnoreAllInputs must be reset.)

        Values below are like for "FLY" mode, since this is relatively
        safest default for WalkNav (free navigation, no gravity). }

      WalkNav.PreferGravityUpForRotations := true;
      WalkNav.PreferGravityUpForMoving := false;
      WalkNav.Gravity := false;
      WalkNav.IgnoreAllInputs := false;
    end;

  var
    FoundType: boolean;
    I: Integer;
  begin
    FoundType := false;
    if NavigationNode <> nil then
      for I := 0 to NavigationNode.FdType.Count - 1 do
        if NavigationNode.FdType.Items[I] = 'WALK' then
        begin
          SetNavigatorKind(Glw, nkWalk);
          WalkNav.PreferGravityUpForRotations := true;
          WalkNav.PreferGravityUpForMoving := true;
          WalkNav.Gravity := true;
          WalkNav.IgnoreAllInputs := false;
          FoundType := true;
          Break;
        end else
        if NavigationNode.FdType.Items[I] = 'FLY' then
        begin
          SetNavigatorKind(Glw, nkWalk);
          WalkNav.PreferGravityUpForRotations := true;
          WalkNav.PreferGravityUpForMoving := false;
          WalkNav.Gravity := false;
          WalkNav.IgnoreAllInputs := false;
          FoundType := true;
          Break;
        end else
        if NavigationNode.FdType.Items[I] = 'NONE' then
        begin
          SetNavigatorKind(Glw, nkWalk);
          WalkNav.PreferGravityUpForRotations := true;
          WalkNav.PreferGravityUpForMoving := true; { doesn't matter }
          WalkNav.Gravity := false;
          WalkNav.IgnoreAllInputs := true;
          FoundType := true;
          Break;
        end else
        if NavigationNode.FdType.Items[I] = 'EXAMINE' then
        begin
          SetExamineNavigationType;
          FoundType := true;
          Break;
        end;

    if not FoundType then
      SetExamineNavigationType;

    if MenuGravity <> nil then
      MenuGravity.Checked := WalkNav.Gravity;
    if MenuIgnoreAllInputs <> nil then
      MenuIgnoreAllInputs.Checked := WalkNav.IgnoreAllInputs;
    if MenuPreferGravityUpForRotations <> nil then
      MenuPreferGravityUpForRotations.Checked := WalkNav.PreferGravityUpForRotations;
    if MenuPreferGravityUpForMoving <> nil then
      MenuPreferGravityUpForMoving.Checked := WalkNav.PreferGravityUpForMoving;
  end;

var
  NewCaption: string;
  CameraPreferredHeight, CameraRadius: Single;
  WorldInfoNode: TNodeWorldInfo;
  I: Integer;
  SavedCameraPos, SavedCameraDir, SavedCameraUp, SavedGravityUp: TVector3Single;
begin
  FreeScene;

  try
    SceneFileName := ASceneFileName;

    if AnimationTimeSpeedWhenLoading <> 1.0 then
      ScaleAll(ATimes, 1 / AnimationTimeSpeedWhenLoading);

    { Optimization is changed here, as it's best to do it when scene
      is not loaded. }
    Optimization := NewOptimization;
    if OptimizationMenu[Optimization] <> nil then
      OptimizationMenu[Optimization].Checked := true;
    SceneAnimation.Optimization := Optimization;

    SceneAnimation.Load(RootNodes, true, ATimes,
      ScenesPerTime, EqualityEpsilon);
    SceneAnimation.TimeLoop := TimeLoop;
    SceneAnimation.TimeBackwards := TimeBackwards;

    if (SceneAnimation.ScenesCount > 1) or
       ( (NavigationNode <> nil) and
         (NavigationNode is TNodeKambiNavigationInfo) and
         TNodeKambiNavigationInfo(NavigationNode).FdTimeOriginAtLoad.Value )
       then
    begin
      WorldTimeAtLoad := 0.0;
      AnimationTime := SceneAnimation.TimeBegin;
    end else
    begin
      WorldTimeAtLoad := DateTimeToUnix(Now);
      AnimationTime := WorldTimeAtLoad;
    end;
    ResetWorldTime(AnimationTime);

    ChangeSceneAnimation(SceneChanges, SceneAnimation);

    { calculate CameraRadius }
    CameraRadius := ACameraRadius;
    if CameraRadius = 0.0 then
    begin
      if (NavigationNode <> nil) and (NavigationNode.FdAvatarSize.Count >= 1) then
        CameraRadius := NavigationNode.FdAvatarSize.Items[0];
      if CameraRadius = 0.0 then
        if IsEmptyBox3d(SceneAnimation.BoundingBoxSum) then
          CameraRadius := 1.0 { any non-zero dummy value } else
          CameraRadius := Box3dAvgSize(SceneAnimation.BoundingBoxSum) * 0.005;
    end;

    { calculate CameraPreferredHeight }
    if (NavigationNode <> nil) and (NavigationNode.FdAvatarSize.Count >= 2) then
      CameraPreferredHeight := NavigationNode.FdAvatarSize.Items[1] else
      { Make it something >> CameraRadius * 2, to allow some
        space to decrease (e.g. by Input_DecreaseCameraPreferredHeight
        in view3dscene). Remember that CorrectCameraPreferredHeight
        adds a limit to CameraPreferredHeight, around CameraRadius * 2. }
      CameraPreferredHeight := CameraRadius * 4;

    if not JumpToInitialViewpoint then
    begin
      { TODO: this should preserve previously bound viewpoint. }
      SavedCameraPos := WalkNav.CameraPos;
      SavedCameraDir := WalkNav.CameraDir;
      SavedCameraUp := WalkNav.CameraUp;
      SavedGravityUp := WalkNav.GravityUp;
    end;

    SceneInitMultiNavigators(SceneAnimation.BoundingBoxSum,
      StdVRMLCamPos[1], StdVRMLCamDir, StdVRMLCamUp, StdVRMLGravityUp,
      CameraPreferredHeight, CameraRadius);

    { calculate ViewpointsList, including MenuJumpToViewpoint,
      and jump to 1st viewpoint (or to the default cam settings). }
    ViewpointsList.Recalculate(SceneAnimation.FirstScene);
    UpdateViewpointNode;

    if not JumpToInitialViewpoint then
    begin
      WalkNav.CameraPos := SavedCameraPos;
      WalkNav.CameraDir := SavedCameraDir;
      WalkNav.CameraUp := SavedCameraUp;
      WalkNav.GravityUp := SavedGravityUp;
    end;

    SceneInitLights(SceneAnimation, NavigationNode);
    SceneHeadlight := SceneAnimation.FirstScene.CreateHeadLight;

    { SceneInitLights could change HeadLight value.
      So update MenuHeadlight.Checked now. }
    if MenuHeadlight <> nil then
      MenuHeadlight.Checked := HeadLight;

    WorldInfoNode := SceneAnimation.FirstScene.RootNode.TryFindNode(
      TNodeWorldInfo, true)
      as TNodeWorldInfo;
    if (WorldInfoNode <> nil) and (WorldInfoNode.FdTitle.Value <> '') then
      NewCaption := SForCaption(WorldInfoNode.FdTitle.Value) else
      NewCaption := ExtractFileName(SceneFilename);
    NewCaption += ' - view3dscene';
    if Glw.Closed then
      Glw.Caption := NewCaption else
      Glw.FPSBaseCaption := NewCaption;

    SetNavigationType;

    SceneOctreeCreate;

    for I := 0 to SceneAnimation.ScenesCount - 1 do
    begin
      { TODO: for now, SceneProcessEvents is always @true when scenes count = 1 }

      { Order is somewhat important here: first turn DebugLogVRMLChanges on,
        then turn events on, otherwise events on initialize() of scripts
        will not be logged. }
      SceneAnimation.Scenes[I].LogChanges := DebugLogVRMLChanges;

      SceneAnimation.Scenes[I].ProcessEvents := SceneAnimation.ScenesCount = 1;

      SceneAnimation.Scenes[I].OnGeometryChanged := @Helper.GeometryChanged;
      SceneAnimation.Scenes[I].OnPostRedisplay := @Helper.PostRedisplay;
      SceneAnimation.Scenes[I].ViewpointStack.OnBoundChanged := @Helper.BoundViewpointChanged;
      SceneAnimation.Scenes[I].OnViewpointsChanged := @Helper.ViewpointsChanged;
      SceneAnimation.Scenes[I].OnBoundViewpointVectorsChanged := @Helper.BoundViewpointVectorsChanged;

    end;

    { Make initial ViewerChanged to make initial events to
      ProximitySensor, if user is within. Even when default navigation
      method is not walker --- we want to allow special ProximitySensor
      nodes that are placed just to start anim on loading to work. }
    if SceneAnimation.ScenesCount = 1 then
      SceneAnimation.Scenes[0].ViewerChanged(
        WalkNav.CameraPos, WalkNav.CameraDir, WalkNav.CameraUp);

    if not Glw.Closed then
    begin
      { call EventResize to adjust zNear/zFar of our projection to the size
        of Scene.BoundingBox }
      Glw.EventResize;
      Glw.PostRedisplay;
    end;

    if MenuReopen <> nil then
      MenuReopen.Enabled := SceneFileName <> '';
  except
    FreeScene;
    raise;
  end;
end;

{ This loads the scene from file (using LoadAsVRMLSequence) and
  then inits our scene variables by LoadSceneCore.

  If it fails, it tries to preserve current scene
  (if it can't preserve current scene, only then it resets it to clear scene).
  Also, it shows the error message using MessageOK
  (so Glw must be already open).

  It may seem that ASceneFileName could be constant parameter here.
  Yes, it could. However, you will sometimes want to pass here
  SceneFileName global value and this would cause memory havoc
  (parameter is passed as const, however when global variable
  SceneFileName is changed then the parameter value implicitly
  changes, it may even cause suddenly invalid pointer --- yeah,
  I experienced it). }
procedure LoadScene(ASceneFileName: string;
  const SceneChanges: TSceneChanges; const ACameraRadius: Single;
  JumpToInitialViewpoint: boolean);

{ It's useful to undefine it only for debug purposes:
  FPC dumps then backtrace of where exception happened,
  which is often enough to trace the error.
  In release versions this should be defined to produce a nice
  message box in case of errors (instead of just a crash). }
{$define CATCH_EXCEPTIONS}

var
  RootNodes: TVRMLNodesList;
  Times: TDynSingleArray;
  ScenesPerTime: Cardinal;
  EqualityEpsilon: Single;
  TimeLoop, TimeBackwards: boolean;
  NewOptimization: TGLRendererOptimization;
  SavedSceneWarnings: TSceneWarnings;
begin
  RootNodes := TVRMLNodesList.Create;
  Times := TDynSingleArray.Create;
  try
    { TODO: Show to user that optimization for kanim is from kanim file,
      not current setting of Optimization ?
      Optimization is now user's preference,
      but we silently override it when loading from KAnim file - not nice. }

    NewOptimization := Optimization;

    { We have to clear SceneWarnings here (not later)
      to catch also all warnings raised during parsing the VRML file.
      This causes a potential problem: if loading the scene will fail,
      we should restore the old warnings (if the old scene will be
      preserved) or clear them (if the clear scene will be loaded
      --- LoadSceneClear will clear them). }
    SavedSceneWarnings := TSceneWarnings.Create;
    try
      SavedSceneWarnings.Assign(SceneWarnings);
      SceneWarnings.Clear;

      {$ifdef CATCH_EXCEPTIONS}
      try
      {$endif CATCH_EXCEPTIONS}
        LoadAsVRMLSequence(ASceneFileName, true,
          RootNodes, Times,
          ScenesPerTime, NewOptimization, EqualityEpsilon,
          TimeLoop, TimeBackwards);
      {$ifdef CATCH_EXCEPTIONS}
      except
        on E: Exception do
        begin
          MessageOK(glw, 'Error while loading scene from "' +ASceneFileName+ '": ' +
            E.Message, taLeft);
          { In this case we can preserve current scene. }
          SceneWarnings.Assign(SavedSceneWarnings);
          Exit;
        end;
      end;
      {$endif CATCH_EXCEPTIONS}
    finally FreeAndNil(SavedSceneWarnings) end;

    {$ifdef CATCH_EXCEPTIONS}
    try
    {$endif CATCH_EXCEPTIONS}
      LoadSceneCore(
        RootNodes, Times,
        ScenesPerTime, NewOptimization, EqualityEpsilon,
        TimeLoop, TimeBackwards,
        ASceneFileName, SceneChanges, ACameraRadius, JumpToInitialViewpoint);
    {$ifdef CATCH_EXCEPTIONS}
    except
      on E: Exception do
      begin
        { In this case we cannot preserve old scene, because
          LoadSceneCore does FreeScene when it exits with exception
          (and that's because LoadSceneCore modifies some global scene variables
          when it works --- so when something fails inside LoadSceneCore,
          we are left with some partially-initiaized state,
          that is not usable; actually, LoadSceneCore
          also does FreeScene when it starts it's work --- to start
          with a clean state).

          We call LoadClearScene before we call MessageOK, this way
          our Draw routine works OK when it's called to draw background
          under MessageOK. }
        LoadClearScene;
        MessageOK(glw, 'Error while loading scene from "' + ASceneFileName + '": ' +
          E.Message, taLeft);
        Exit;
      end;
    end;
    {$endif CATCH_EXCEPTIONS}

    { For batch operation (making screenshots), do not save the scene
      on "recent files" menu. This also applies when using view3dscene
      as a thumbnailer. }
    if not MakingScreenShot then
      RecentMenu.Add(ASceneFileName);

    { We call PrepareRender to make SceneAnimation.PrepareRender to gather
      VRML warnings (because some warnings, e.g. invalid texture filename,
      are reported only from SceneAnimation.PrepareRender).
      Also, this allows us to show first PrepareRender with progress bar. }
    PrepareRender(true);
    if (SceneWarnings.Count <> 0) and
       { For MakingScreenShot, work non-interactively.
         Warnings are displayed at stderr anyway, so user will see them there. }
       (not MakingScreenShot) then
      MessageOK(Glw, Format('Note that there were %d warnings while loading ' +
        'this scene. See the console or use File->"View warnings" ' +
        'menu command to view them all.', [SceneWarnings.Count]), taLeft);
  finally
    FreeAndNil(RootNodes);
    FreeAndNil(Times);
  end;
end;

{ This should be used to load special "clear" and "welcome" scenes.
  This loads a scene directly from TVRMLNode, and assumes that
  LoadSceneCore will not fail. }
procedure LoadSimpleScene(Node: TVRMLNode);
var
  RootNodes: TVRMLNodesList;
  Times: TDynSingleArray;
  ScenesPerTime: Cardinal;
  EqualityEpsilon: Single;
  TimeLoop, TimeBackwards: boolean;
begin
  RootNodes := TVRMLNodesList.Create;
  Times := TDynSingleArray.Create;
  try
    RootNodes.Add(Node);
    Times.AppendItem(0);

    ScenesPerTime := 1;      { doesn't matter }
    EqualityEpsilon := 0.0;  { doesn't matter }
    TimeLoop := false;      { doesn't matter }
    TimeBackwards := false; { doesn't matter }

    SceneWarnings.Clear;
    LoadSceneCore(
      RootNodes, Times,
      ScenesPerTime,
      { keep current Optimization } Optimization,
      EqualityEpsilon,
      TimeLoop, TimeBackwards,
      '', [], 1.0, true);
  finally
    FreeAndNil(RootNodes);
    FreeAndNil(Times);
  end;
end;

{ This works like LoadScene, but loaded scene is an empty scene.
  More specifically, this calls FreeScene, and then inits
  "scene global variables" to some non-null values. }
procedure LoadClearScene;
begin
  { As a clear scene, I'm simply loading an empty VRML file.
    This way everything seems normal: SceneAnimation is Loaded,
    FirstScene is available and FirstScene.RootNode is non-nil.

    The other idea was to use some special state like Loaded = @false
    to indicate clear scene, but this would only complicate code
    with checks for "if Loaded" everywhere.

    Also, non-empty clear scene allows me to put there WorldInfo with a title.
    This way clear scene has an effect on view3dscene window's title,
    and at the same time I don't have to set SceneFileName to something
    dummy.

    I'm not constructing here RootNode in code (i.e. Pascal).
    This would allow a fast implementation, but it's easier for me to
    design scene in pure VRML and then auto-generate
    xxx_scene.inc file to load VRML scene from a simple string. }
  LoadSimpleScene(ParseVRMLFileFromString({$I clear_scene.inc}, ''));
end;

{ like LoadClearScene, but this loads a little more complicated scene.
  It's a "welcome scene" of view3dscene. }
procedure LoadWelcomeScene;
begin
  LoadSimpleScene(ParseVRMLFileFromString({$I welcome_scene.inc}, ''));
end;

function SavedVRMLPrecedingComment(const SourceFileName: string): string;
begin
 Result := 'VRML generated by view3dscene from ' +SourceFileName +
   ' on ' +DateTimeToAtStr(Now);
end;

{ Load model from ASceneFileName ('-' means stdin),
  do SceneChanges, and write it as VRML to stdout.
  This is simply the function to handle --write-to-vrml command-line option. }
procedure WriteToVRML(const ASceneFileName: string;
  const SceneChanges: TSceneChanges);
var Scene: TVRMLScene;
begin
 Scene := TVRMLScene.Create(LoadAsVRML(ASceneFileName, true), true);
 try
  ChangeScene(SceneChanges, Scene);
  SaveToVRMLFile(Scene.RootNode, StdOutStream,
    SavedVRMLPrecedingComment(ASceneFileName));
 finally Scene.Free end;
end;

class procedure THelper.OpenRecent(const FileName: string);
begin
  LoadScene(FileName, [], 0.0, true);
end;

class procedure THelper.GeometryChanged(Scene: TVRMLScene;
  const SomeLocalGeometryChanged: boolean);
begin
  if SomeLocalGeometryChanged then
    { Since some PVRMLTriangle pointers are possibly completely different now,
      we have to invalidate selection. }
    Unselect else
  if SelectedItem <> nil then
  begin
    { We can keep SelectedItem, but we have to take into account that it's
      transformation possibly changed. So world coordinates of this triangle
      are different. }
    SelectedItem^.UpdateWorld;

    { Also SelectedPointWorld changed now. To apply the change, convert
      SelectedPointLocal to world coords by new trasform.
      This is the main reason why we keep SelectedPointLocal recorded. }
    try
      SelectedPointWorld := MatrixMultPoint(SelectedItem^.State.Transform,
        SelectedPointLocal);
    except
      on ETransformedResultInvalid do
        Unselect;
    end;

  end;
end;

class procedure THelper.PostRedisplay(Scene: TVRMLScene);
begin
  Glw.PostRedisplay;
end;

{ make screen shots ---------------------------------------------------------- }

{ This performs all screenshot takes, as specified in ScreenShotsList.
  It is used both for batch mode screenshots (--screenshot, --screenshot-range)
  and interactive (menu items about screenshots) operation. }
procedure MakeAllScreenShots;
var
  I, J: Integer;
  OldProgressUserInterface: TProgressUserInterface;
  OldAnimationTime: TKamTime;
begin
  { Save global things that we change, to restore them later.
    This isn't needed for batch mode screenshots, but it doesn't hurt
    to be clean. }
  OldProgressUserInterface := Progress.UserInterface;
  OldAnimationTime := AnimationTime;
  try
    BeforeDraw(Glw);

    { For TRangeScreenShot to display progress on console
      (it cannot display progress on GL window, since this would
      mess rendered image; besides, in the future GL window may be
      hidden during rendering). }
    Progress.UserInterface := ProgressConsoleInterface;

    ScreenShotsList.BeginCapture;

    for I := 0 to ScreenShotsList.Count - 1 do
    begin
      ScreenShotsList[I].BeginCapture;
      try
        for J := 0 to ScreenShotsList[I].Count - 1 do
        begin
          AnimationTime := ScreenShotsList[I].UseTime(J);
          ResetWorldTime(AnimationTime);
          Draw(Glw);
          glFlush();
          SaveScreen_NoFlush(ScreenShotsList[I].UseFileName(J), GL_BACK);
        end;
        ScreenShotsList[I].EndCapture(true);
      except
        ScreenShotsList[I].EndCapture(false);
        raise;
      end;
    end;

  finally
    Progress.UserInterface := OldProgressUserInterface;
    AnimationTime := OldAnimationTime;
    ResetWorldTime(AnimationTime);
  end;
end;

{ menu things ------------------------------------------------------------ }

const
  Version = '3.3.0';
  DisplayProgramName = 'view3dscene';

var
  MenuOctreeDisplayWhole: TMenuItemChecked;

type
  THelperSpecialCastleNodes = class
    procedure Remove(ParentNode: TVRMLNode; var Node: TVRMLNode);
  end;

procedure THelperSpecialCastleNodes.Remove(
  ParentNode: TVRMLNode; var Node: TVRMLNode);
begin
  if (Node.NodeName = 'LevelBox') or
     (Node.NodeName = 'WaterBox') or
     IsPrefix('Crea', Node.NodeName) or
     IsPrefix('Item', Node.NodeName) or
     IsPrefix('Waypoint', Node.NodeName) or
     IsPrefix('Sector', Node.NodeName) or
     { Actually below are special only on specific levels. Oh, well... there's
       no way to solve it in view3dscene (and I obviously don't want to
       make view3dscene depend on any "The Castle" units --- view3dscene
       is completely independent). }
     (Node.NodeName = 'LevelExitBox') or
     IsPrefix('WerewolfAppear_', Node.NodeName) or
     (Node.NodeName = 'GateExitBox') or
     (Node.NodeName = 'Teleport1Box') or
     (Node.NodeName = 'Teleport2Box') or
     (Node.NodeName = 'SacrilegeBox') or
     IsPrefix('SacrilegeGhost_', Node.NodeName) or
     IsPrefix('SwordGhost_', Node.NodeName) or
     (Node.NodeName = 'Elevator49DownBox') or
     (Node.NodeName = 'Elev9a9bPickBox') then
    Node := nil;
end;

type
  TShaderAdder = class
    ProgramNode: TNodeComposedShader;
    Added: boolean;
    procedure AddShader(Node: TVRMLNode);
  end;

procedure TShaderAdder.AddShader(Node: TVRMLNode);
var
  ShadersField: TMFNode;
begin
  ShadersField := (Node as TNodeAppearance).FdShaders;
  if not ((ShadersField.Count = 1) and (ShadersField.Items[0] = ProgramNode)) then
  begin
    ShadersField.ClearItems;
    ShadersField.AddItem(ProgramNode);
    Added := true;
  end;
end;

procedure MenuCommand(Glwin: TGLWindow; MenuItem: TMenuItem);

  procedure ChangeGravityUp;
  var Answer: string;
      NewUp: TVector3Single;
  begin
   if Glw.Navigator is TWalkNavigator then
   begin
    Answer := '';
    if MessageInputQuery(Glwin,
      'Input new camera up vector (three float values).' +nl+nl+
      'This vector will be used as new gravity upward vector. ' +
      'This vector must not be zero vector.',
      Answer, taLeft) then
    begin

     try
      NewUp := Vector3SingleFromStr(Answer);
     except
      on E: EConvertError do
      begin
       MessageOK(Glwin, 'Incorrect vector value : '+E.Message);
       Exit;
      end;
     end;

     Glw.WalkNav.GravityUp := NewUp;
     Glw.PostRedisplay;
    end;
   end else
    MessageOK(Glwin, SOnlyInWalker);
  end;

  procedure ChangeMoveSpeed;
  var
    MoveSpeed: Single;
  begin
    if Glw.Navigator is TWalkNavigator then
    begin
      { in view3dscene, MoveHorizontalSpeed is always equal
        MoveVerticalSpeed }

      MoveSpeed := Glw.WalkNav.MoveHorizontalSpeed;
      if MessageInputQuery(Glwin, 'New move speed:', MoveSpeed, taLeft) then
      begin
        Glw.WalkNav.MoveHorizontalSpeed := MoveSpeed;
        Glw.WalkNav.MoveVerticalSpeed := MoveSpeed;
        Glw.PostRedisplay;
      end;
    end else
      MessageOK(Glwin, SOnlyInWalker);
  end;


  procedure ShowAndWrite(const S: string);
  begin
    Writeln(S);
    MessageOK(Glw, S, taLeft);
  end;

  procedure ViewSceneWarnings;
  var
    S: TStringList;
  begin
    S := TStringList.Create;
    try
      S.Append(Format('Total %d warnings about current scene "%s":',
        [ SceneWarnings.Count, SceneFileName ]));
      S.Append('');
      S.AddStrings(SceneWarnings.Items);
      MessageOK(Glw, S, taLeft);
    finally FreeAndNil(S) end;
  end;

  procedure ChangePointSize;
  var
    Value: Single;
  begin
    Value := SceneAnimation.Attributes.PointSize;
    if MessageInputQuery(Glwin, 'Change point size:',
      Value, taLeft) then
      SceneAnimation.Attributes.PointSize := Value;
  end;

  procedure ChangeWireframeWidth;
  var
    Value: Single;
  begin
    Value := SceneAnimation.Attributes.WireframeWidth;
    if MessageInputQuery(Glwin, 'Change wireframe line width:',
      Value, taLeft) then
      SceneAnimation.Attributes.WireframeWidth := Value;
  end;

  procedure ChangeAnimationTimeSpeed;
  begin
    MessageInputQuery(Glwin,
      'Playing speed 1.0 means that 1 time unit is 1 second.' +nl+
      '0.5 makes playing animation two times slower,' +nl+
      '2.0 makes it two times faster etc.' +nl+
      nl+
      'Note that this is the "on display" playing speed.' +nl+
      nl+
      '- For pracalculated ' +
      'animations (like from Kanim or MD3 files), this means ' +
      'that internally number of precalculated animation frames ' +
      'doesn''t change. Which means that slowing this speed too much ' +
      'leads to noticeably "jagged" animations.' +nl+
      nl+
      '- For interactive animations (played and calculated from a single ' +
      'VRML / X3D file, e.g. by VRML interpolators) this is perfect, ' +
      'animation always remains smooth.' +nl+
      nl+
      'New "on display" playing speed:',
      AnimationTimeSpeed, taLeft);
  end;

  procedure ChangeAnimationTimeSpeedWhenLoading;
  begin
    MessageInputQuery(Glwin,
      'Playing speed 1.0 means that 1 time unit is 1 second.' +nl+
      '0.5 makes playing animation two times slower,' +nl+
      '2.0 makes it two times faster etc.' +nl+
      nl+
      'Note that this is the "on loading" playing speed. Which means ' +
      'it''s only applied when loading animation from file ' +
      '(you can use "File -> Reopen" command to apply this to currently ' +
      'loaded animation).' +nl+
      nl+
      '- For pracalculated ' +
      'animations (like from Kanim or MD3 files), changing this actually changes ' +
      'the density of precalculated animation frames. Which means that ' +
      'this is the more resource-consuming, but also better ' +
      'method of changing animation speed: even if you slow down ' +
      'this playing speed much, the animation will remain smooth.' +nl+
      nl+
      '- For interactive animations (played and calculated from a single ' +
      'VRML / X3D file, e.g. by VRML interpolators) this has no effect, ' +
      'as no frames are precalculated at loading. Use "on display" playing speed ' +
      'instead.' +nl+
      nl+
      'New "on loading" playing speed:',
      AnimationTimeSpeedWhenLoading, taLeft);
  end;

  function NodeNiceName(node: TVRMLNode): string;
  begin
   result := ''''+node.NodeName+''' (class '''+node.NodeTypeName+''')';
  end;

  procedure SelectedShowInformation;
  var
    s, TextureDescription: string;
    VCOver, TCOver, VCNotOver, TCNotOver: Cardinal;
    M1: TNodeMaterial_1;
    M2: TNodeMaterial_2;
    SelectedGeometry: TVRMLGeometryNode;
    Tex: TNodeX3DTextureNode;
  begin
    if SelectedItem = nil then
    begin
      s := 'Nothing selected.';
    end else
    begin
      SelectedGeometry := SelectedItem^.Geometry;
      s := Format(
           'Selected point %s from triangle %s (triangle id: %s).' +nl+
           nl+
           'This triangle is part of the '+
           'node named %s. Node''s bounding box is %s. ',
           [VectorToNiceStr(SelectedPointWorld),
            TriangleToNiceStr(SelectedItem^.World.Triangle),
            PointerToStr(SelectedItem),
            NodeNiceName(SelectedGeometry),
            Box3dToNiceStr(SelectedGeometry.BoundingBox(SelectedItem^.State))]);

      if (SelectedItem^.FaceCoordIndexBegin <> -1) and
         (SelectedItem^.FaceCoordIndexEnd <> -1) then
      begin
        S += Format('Face containing the selected triangle spans from %d to' +
          ' %d coordIndex entries. ',
          [ SelectedItem^.FaceCoordIndexBegin,
            SelectedItem^.FaceCoordIndexEnd ]);
      end;

      VCNotOver := SelectedGeometry.VerticesCount(SelectedItem^.State, false);
      TCNotOver := SelectedGeometry.TrianglesCount(SelectedItem^.State, false);
      VCOver := SelectedGeometry.VerticesCount(SelectedItem^.State, true);
      TCOver := SelectedGeometry.TrianglesCount(SelectedItem^.State, true);

      if (VCOver = VCNotOver) and (TCOver = TCNotOver) then
      begin
       s += Format(
              'Node has %d vertices and %d triangles '+
              '(with and without over-triangulating).',
              [VCNotOver, TCNotOver]);
      end else
      begin
       s += Format(
              'When we don''t use over-triangulating (e.g. for raytracing and '+
              'collision-detection) node has %d vertices and %d triangles. '+
              'When we use over-triangulating (e.g. for real-time rendering) '+
              'node has %d vertices and %d triangles.',
              [VCNotOver, TCNotOver, VCOver, TCOver]);
      end;

      { calculate Tex }
      Tex := SelectedItem^.State.Texture;

      { calculate TextureDescription }
      if Tex = nil then
        TextureDescription := 'none' else
      if Tex is TVRMLTextureNode then
        TextureDescription := TVRMLTextureNode(Tex).TextureDescription else
        TextureDescription := Tex.NodeTypeName;

      S += Format(nl +nl+ 'Node''s texture : %s.', [TextureDescription]);

      S += nl+ nl;
      if SelectedItem^.State.ParentShape <> nil then
      begin
        { This is VRML 2.0 node }
        M2 := SelectedItem^.State.ParentShape.Material;
        if M2 <> nil then
        begin
          S += Format(
                 'Material (VRML >= 2.0):' +nl+
                 '  name : %s' +nl+
                 '  ambientIntensity : %s' +nl+
                 '  diffuseColor : %s' +nl+
                 '  specular : %s' +nl+
                 '  shininess : %s' +nl+
                 '  transparency : %s',
                 [ M2.NodeName,
                   FloatToNiceStr(M2.FdAmbientIntensity.Value),
                   VectorToNiceStr(M2.FdDiffuseColor.Value),
                   VectorToNiceStr(M2.FdSpecularColor.Value),
                   FloatToNiceStr(M2.FdShininess.Value),
                   FloatToNiceStr(M2.FdTransparency.Value) ]);
        end else
          S += 'Material: NULL';
      end else
      begin
        M1 := SelectedItem^.State.LastNodes.Material;
        S += Format(
            'Material (VRML <= 1.0):' +nl+
            '  name : %s' +nl+
            '  ambientColor[0] : %s' +nl+
            '  diffuseColor[0] : %s' +nl+
            '  specularColor[0] : %s' +nl+
            '  shininess[0] : %s' +nl+
            '  transparency[0] : %s',
            [ M1.NodeName,
              VectorToNiceStr(M1.AmbientColor3Single(0)),
              VectorToNiceStr(M1.DiffuseColor3Single(0)),
              VectorToNiceStr(M1.SpecularColor3Single(0)),
              FloatToNiceStr(M1.Shininess(0)),
              FloatToNiceStr(M1.Transparency(0)) ]);
      end;
    end;
    ShowAndWrite(S);
  end;

  procedure SelectedShowLightsInformation;
  var
    i: integer;
    ShadowingItem: PVRMLTriangle;
    S: string;
    ActiveLights: TDynActiveLightArray;
  begin
    if SelectedItem = nil then
    begin
      s := 'Nothing selected.';
    end else
    begin
      ActiveLights := SelectedItem^.State.CurrentActiveLights;

      S := Format('Total %d lights active for selected object.',
        [ActiveLights.Count]);

      for i := 0 to ActiveLights.Count - 1 do
      begin
       s += nl+ nl + Format('Light %d (node %s) possibly affects selected point ... ',
         [ I, NodeNiceName(ActiveLights.Items[i].LightNode) ]);

       ShadowingItem := SceneOctreeCollisions.SegmentCollision(
         SelectedPointWorld, ActiveLights.Items[i].TransfLocation,
           false, SelectedItem, true, nil);

       if ShadowingItem <> nil then
       begin
        s += Format('but no, this light is blocked by triangle %s from node %s.',
          [ TriangleToNiceStr(ShadowingItem^.World.Triangle),
            NodeNiceName(ShadowingItem^.Geometry) ])
       end else
        s += 'hmm, yes ! No object blocks this light here.';
      end;
    end;

    ShowAndWrite(S);
  end;

  procedure RemoveSelectedGeometry;
  begin
    if SceneAnimation.ScenesCount > 1 then
    begin
      { We can't do this for animations, because we use
        SelectedItem^.Geometry, so this is only for the frame where
        octree is available. }
      MessageOK(Glwin, 'This function is not available when you deal with ' +
        'precalculated animations (like from Kanim or MD3 files).', taLeft);
      Exit;
    end;

    if SelectedItem = nil then
    begin
      ShowAndWrite('Nothing selected.');
    end else
    begin
      SelectedItem^.Geometry.FreeRemovingFromAllParents;
      SceneAnimation.Scenes[0].ChangedAll;
    end;
  end;

  procedure RemoveSelectedFace;

    function MFNonEmpty(Field: TDynLongIntArray): boolean;
    begin
      Result := (Field <> nil) and (Field.Count > 0) and
        { Single "-1" value in an MF field is the VRML 1.0 default
          weird value for normalIndex, materialIndex and textureCoordIndex
          fields. We treat it like an empty field, otherwise we wouldn't
          be able to process most VRML 1.0 files. }
        (not ((Field.Count = 1) and (Field.Items[0] = -1)));
    end;

  var
    Geometry: TVRMLGeometryNode;
    Colors, Coords, Materials, Normals, TexCoords: TDynLongIntArray;
  begin
    if SceneAnimation.ScenesCount > 1 then
    begin
      { We can't do this for animations, because we use
        SelectedItem^.Geometry, so this is only for the frame where
        octree is available. Moreover, we call
        SceneAnimation.FirstScene.ChangedFields. }
      MessageOK(Glwin, 'This function is not available when you deal with ' +
        'precalculated animations (like from Kanim or MD3 files).', taLeft);
      Exit;
    end;

    if SelectedItem = nil then
    begin
      ShowAndWrite('Nothing selected.');
      Exit;
    end;

    if (SelectedItem^.FaceCoordIndexBegin = -1) or
       (SelectedItem^.FaceCoordIndexEnd = -1) then
    begin
      ShowAndWrite('The selected triangle is not part of IndexedFaceSet node.');
      Exit;
    end;

    Geometry := SelectedItem^.Geometry;

    if Geometry is TNodeIndexedFaceSet_1 then
    begin
      Colors := nil;
      Coords := TNodeIndexedFaceSet_1(Geometry).FdCoordIndex.Items;
      Materials := TNodeIndexedFaceSet_1(Geometry).FdMaterialIndex.Items;
      Normals := TNodeIndexedFaceSet_1(Geometry).FdNormalIndex.Items;
      TexCoords := TNodeIndexedFaceSet_1(Geometry).FdTextureCoordIndex.Items;
    end else
    if Geometry is TNodeIndexedFaceSet_2 then
    begin
      Colors := TNodeIndexedFaceSet_2(Geometry).FdColorIndex.Items;
      Coords := TNodeIndexedFaceSet_2(Geometry).FdCoordIndex.Items;
      Materials := nil;
      Normals := TNodeIndexedFaceSet_2(Geometry).FdNormalIndex.Items;
      TexCoords := TNodeIndexedFaceSet_2(Geometry).FdTexCoordIndex.Items;
    end else
    if Geometry is TNodeIndexedTriangleMesh_1 then
    begin
      Colors := nil;
      Coords := TNodeIndexedTriangleMesh_1(Geometry).FdCoordIndex.Items;
      Materials := TNodeIndexedTriangleMesh_1(Geometry).FdMaterialIndex.Items;
      Normals := TNodeIndexedTriangleMesh_1(Geometry).FdNormalIndex.Items;
      TexCoords := TNodeIndexedTriangleMesh_1(Geometry).FdTextureCoordIndex.Items;
    end else
    begin
      ShowAndWrite('Internal error: cannot get the coordIndex field.');
      Exit;
    end;

    if MFNonEmpty(Colors) or MFNonEmpty(Materials) or MFNonEmpty(Normals) then
    begin
      ShowAndWrite('Removing faces from a geometry node with colorIndex, ' +
        'materialIndex or normalIndex not implemented yet.');
      Exit;
    end;

    Coords.Delete(SelectedItem^.FaceCoordIndexBegin,
      SelectedItem^.FaceCoordIndexEnd -
      SelectedItem^.FaceCoordIndexBegin + 1);

    { Texture coordinates, if not empty, have always (both in VRML 1.0
      and VRML 2.0 IndexedFaceSet nodes, and in IndexedTriangleMesh
      from Inventor) the same ordering as coordIndex.
      So we can remove equivalent texture coords in the same manner
      as we removed coords. }
    if TexCoords <> nil then
      TexCoords.Delete(SelectedItem^.FaceCoordIndexBegin,
        SelectedItem^.FaceCoordIndexEnd -
        SelectedItem^.FaceCoordIndexBegin + 1);

    SceneAnimation.FirstScene.ChangedFields(Geometry, nil);
  end;

  { Returns @true and sets M1 and M2 (exactly one to @nil, one to non-nil)
    if success. Produces message to user and returns @false on failure.

    Note that SelectedItem is not necessarily correct anymore. Use only
    M1 and M2 pointers after this. }
  function ChangeMaterialInit(
    out M1: TNodeMaterial_1;
    out M2: TNodeMaterial_2): boolean;
  var
    Shape: TNodeX3DShapeNode;
  begin
    if SceneAnimation.ScenesCount > 1 then
    begin
      { We can't do this for animations, because we use
        SelectedItem.State, so this is only for the frame where
        octree is available. Moreover, we call
        SceneAnimation.FirstScene.ChangedFields. }
      MessageOK(Glwin, 'This function is not available when you deal with ' +
        'precalculated animations (like from Kanim or MD3 files).', taLeft);
      Exit(false);
    end;

    if (SelectedItem = nil) then
    begin
      ShowAndWrite('Nothing selected.');
      Exit(false);
    end;

    M1 := nil;
    M2 := nil;
    Shape := SelectedItem^.State.ParentShape;
    if Shape <> nil then
    begin
      M2 := Shape.Material;
      if M2 = nil then
      begin
        if MessageYesNo(Glw, 'No material present. Add material to this node and then edit it?', taLeft) then
        begin
          { Note that this may remove old Shape.FdAppearance.Value,
            but only if Shape.Appearance = nil, indicating that
            something wrong was specified for "appearance" field.

            Similar, it may remove old Shape.Appearance.FdMaterial.Value,
            but only if Shape.Material was nil, and together
            this indicates that something incorrect was placed in "material"
            field. }
          if Shape.Appearance = nil then
          begin
            Shape.FdAppearance.Value := TNodeAppearance.Create('', '');
            Assert(Shape.Appearance <> nil);
          end;

          M2 := TNodeMaterial_2.Create('', '');
          Shape.Appearance.FdMaterial.Value := M2;
          SceneAnimation.Scenes[0].ChangedAll;
        end else
          Exit(false);
      end;
    end else
    begin
      M1 := SelectedItem^.State.LastNodes.Material;
    end;

    Result := true;
  end;

  procedure ChangeMaterialDiffuse;
  var
    M1: TNodeMaterial_1;
    M2: TNodeMaterial_2;
    Color: TVector3Single;
  begin
    if not ChangeMaterialInit(M1, M2) then Exit;

    if M2 <> nil then
      Color := M2.FdDiffuseColor.Value else
    begin
      Assert(M1 <> nil);
      if M1.FdDiffuseColor.Count > 0 then
        Color := M1.FdDiffuseColor.Items.Items[0] else
        Color := DefaultMaterialDiffuseColor;
    end;

    if Glwin.ColorDialog(Color) then
    begin
      if M2 <> nil then
      begin
        M2.FdDiffuseColor.EventIn.Send(Color, SceneAnimation.FirstScene.WorldTime);
      end else
      begin
        Assert(M1 <> nil);
        M1.FdDiffuseColor.EventIn.Send([Color], SceneAnimation.FirstScene.WorldTime);
      end;
    end;
  end;

  procedure ChangeMaterialSpecular;
  var
    M1: TNodeMaterial_1;
    M2: TNodeMaterial_2;
    Color: TVector3Single;
  begin
    if not ChangeMaterialInit(M1, M2) then Exit;

    if M2 <> nil then
      Color := M2.FdSpecularColor.Value else
    begin
      Assert(M1 <> nil);
      if M1.FdSpecularColor.Count > 0 then
        Color := M1.FdSpecularColor.Items.Items[0] else
        Color := DefaultMaterialSpecularColor;
    end;

    if Glwin.ColorDialog(Color) then
    begin
      if M2 <> nil then
      begin
        M2.FdSpecularColor.EventIn.Send(Color, SceneAnimation.FirstScene.WorldTime);
      end else
      begin
        Assert(M1 <> nil);
        M1.FdSpecularColor.EventIn.Send([Color], SceneAnimation.FirstScene.WorldTime);
      end;
    end;
  end;

  procedure ChangeLightModelAmbient;
  begin
    if glwin.ColorDialog(LightModelAmbient) then LightModelAmbientChanged;
  end;

  procedure SetViewpointForWholeScene(const WantedCameraUp: Integer);
  var
    CameraPos, CameraDir, CameraUp, GravityUp: TVector3Single;
  begin
    CameraViewpointForWholeScene(SceneAnimation.BoundingBoxSum,
      WantedCameraUp,
      CameraPos, CameraDir, CameraUp, GravityUp);
    SetViewpointCore(CameraPos, CameraDir, CameraUp, GravityUp);
  end;

  procedure RemoveNodesWithMatchingName;
  var
    Wildcard: string;
    RemovedNumber, RemovedNumberOther: Cardinal;
    I: Integer;
  begin
    Wildcard := '';
    if MessageInputQuery(Glwin,
      'Input node name to be removed. You can use wildcards (* and ?) in ' +
      'the expression below to match many node names. The input is ' +
      'case sensitive (like all VRML).',
      Wildcard, taLeft) then
    begin
      RemovedNumber := SceneAnimation.Scenes[0].RootNode.
        RemoveChildrenWithMatchingName(Wildcard, false);
      for I := 1 to SceneAnimation.ScenesCount - 1 do
      begin
        RemovedNumberOther := SceneAnimation.Scenes[I].RootNode.
          RemoveChildrenWithMatchingName(Wildcard, false);
        Assert(RemovedNumberOther = RemovedNumber);
      end;

      if RemovedNumber <> 0 then
        SceneAnimation.Scenes[0].ChangedAll;

      MessageOK(Glwin, Format('Removed %d node instances.', [RemovedNumber]),
        taLeft);
    end;
  end;

  procedure RemoveSpecialCastleNodes;
  var
    RemovedNumber, RemovedNumberOther: Cardinal;
    I: Integer;
    HelperSpecialCastleNodes: THelperSpecialCastleNodes;
  begin
    RemovedNumber := SceneAnimation.Scenes[0].RootNode.
      EnumerateReplaceChildren(@HelperSpecialCastleNodes.Remove);
    for I := 1 to SceneAnimation.ScenesCount - 1 do
    begin
      RemovedNumberOther := SceneAnimation.Scenes[I].RootNode.
        EnumerateReplaceChildren(@HelperSpecialCastleNodes.Remove);
      Assert(RemovedNumberOther = RemovedNumber);
    end;

    if RemovedNumber <> 0 then
      SceneAnimation.Scenes[0].ChangedAll;
    MessageOK(Glwin, Format('Removed %d node instances.', [RemovedNumber]),
      taLeft);
  end;

  procedure WritelnCameraSettings(Version: TVRMLCameraVersion);
  begin
    Writeln(MakeVRMLCameraStr(Version,
      WalkNav.CameraPos,
      WalkNav.CameraDir,
      WalkNav.CameraUp,
      WalkNav.GravityUp));
  end;

  procedure WriteBoundingBox(const Box: TBox3d);
  begin
    if IsEmptyBox3d(Box) then
      MessageOK(Glw, 'The bounding box is empty.', taLeft) else
    begin
      Writeln(Format(
        '# ----------------------------------------' +nl+
        '# BoundingBox %s expressed in VRML:' +nl+
        '# Version for VRML 1.0' +nl+
        'DEF BoundingBox Separator {' +nl+
        '  Translation {' +nl+
        '    translation %s' +nl+
        '  }' +nl+
        '  Cube {' +nl+
        '    width %s' +nl+
        '    height %s' +nl+
        '    depth %s' +nl+
        '  } }' +nl+
        nl+
        '# Version for VRML 2.0' +nl+
        'DEF BoundingBox Transform {' +nl+
        '  translation %1:s' +nl+
        '  children Shape {' +nl+
        '    geometry Box {' +nl+
        '      size %2:s %3:s %4:s' +nl+
        '    } } }',
        [ Box3dToNiceStr(Box),
          VectorToRawStr(Box3dMiddle(Box)),
          FloatToRawStr(Box[1, 0] - Box[0, 0]),
          FloatToRawStr(Box[1, 1] - Box[0, 1]),
          FloatToRawStr(Box[1, 2] - Box[0, 2]) ]));
    end;
  end;

  procedure AssignGLSLShader;
  const
    VS_FileFilters =
    'All files|*|' +
    '*Vertex shader (*.vs)|*.vs';
    FS_FileFilters =
    'All files|*|' +
    '*Fragment shader (*.fs)|*.fs';
  var
    FragmentShaderUrl, VertexShaderUrl: string;
    ProgramNode: TNodeComposedShader;
    ShaderPart: TNodeShaderPart;
    ShaderAdder: TShaderAdder;
    I: Integer;
  begin
    VertexShaderUrl := '';
    if Glwin.FileDialog('Open vertex shader file', VertexShaderUrl, true,
      VS_FileFilters) then
    begin
      { We guess that FragmentShaderUrl will be in the same dir as vertex shader }
      FragmentShaderUrl := ExtractFilePath(VertexShaderUrl);
      if Glwin.FileDialog('Open fragment shader file', FragmentShaderUrl, true,
        FS_FileFilters) then
      begin
        ProgramNode := TNodeComposedShader.Create(
          { any name that has a chance to be unique }
          'view3dscene_shader_' + IntToStr(Random(1000)), '');
        ProgramNode.FdLanguage.Value := 'GLSL';

        ShaderPart := TNodeShaderPart.Create('', '');
        ProgramNode.FdParts.AddItem(ShaderPart);
        ShaderPart.FdType.Value := 'VERTEX';
        ShaderPart.FdUrl.Items.AppendItem(VertexShaderUrl);

        ShaderPart := TNodeShaderPart.Create('', '');
        ProgramNode.FdParts.AddItem(ShaderPart);
        ShaderPart.FdType.Value := 'FRAGMENT';
        ShaderPart.FdUrl.Items.AppendItem(FragmentShaderUrl);

        ShaderAdder := TShaderAdder.Create;
        try
          ShaderAdder.ProgramNode := ProgramNode;
          ShaderAdder.Added := false;

          for I := 0 to SceneAnimation.ScenesCount - 1 do
          begin
            SceneAnimation.Scenes[I].RootNode.EnumerateNodes(TNodeAppearance,
              @ShaderAdder.AddShader, false);
          end;

          if ShaderAdder.Added then
          begin
            for I := 0 to SceneAnimation.ScenesCount - 1 do
              SceneAnimation.Scenes[I].ChangedAll;
          end else
          begin
            FreeAndNil(ProgramNode);
            MessageOK(Glw, 'No shaders added.' +NL+
              'Hint: this feature adds shaders to Apperance.shaders field. ' +
              'So it requires VRML >= 2.0 models with Appearance nodes present, ' +
              'otherwise nothing will be added.',
              taLeft);
          end;
        finally FreeAndNil(ShaderAdder); end;
      end;
    end;
  end;

  procedure SetFillMode(Value: TFillMode);
  begin
    FillMode := Value;
    { For fmSilhouetteBorderEdges, these things can remain as they were
      previously. }
    if FillMode <> fmSilhouetteBorderEdges then
    begin
      SceneAnimation.Attributes.WireframeEffect := FillModes[FillMode].WireframeEffect;
      SceneAnimation.Attributes.WireframeColor  := FillModes[FillMode].WireframeColor;
      SceneAnimation.Attributes.PureGeometry    := FillModes[FillMode].PureGeometry;
    end;
  end;

  procedure ScreenShotToVideo;
  var
    TimeBegin, TimeStep: TKamTime;
    FramesCount: Cardinal;
    FileNamePattern: string;
    Range: TRangeScreenShot;
  begin
    TimeBegin := AnimationTime;
    TimeStep := 0.04;
    FramesCount := 25;
    FileNamePattern := 'image%d.png';

    if MessageInputQuery(Glwin, 'Input start time for recording movie:',
      TimeBegin, taLeft) then
      if MessageInputQuery(Glwin, 'Time step between capturing movie frames:' +NL+NL+
        'Note that if you later choose to record to a single movie file, like "output.avi", then we''ll generate a movie with 25 frames per second. ' +
        'So if you want your movie to play with the same speed as animation in view3dscene then the default value, 1/25, is good.' +NL+NL+
        'Input time step between capturing movie frames:', TimeStep, taLeft) then
        if MessageInputQueryCardinal(Glwin, 'Input frames count to capture:', FramesCount, taLeft) then
          if Glwin.FileDialog('Images pattern or movie filename to save', FileNamePattern, false) then
          begin
            { ScreenShotsList should always be empty in interactive mode
              (otherwise some rendering behaves differently when
              MakingScreenShot = true) }
            Assert(ScreenShotsList.Count = 0);

            Range := TRangeScreenShot.Create;
            Range.TimeBegin := TimeBegin;
            Range.TimeStep := TimeStep;
            Range.FramesCount := FramesCount;
            Range.FileNamePattern := FileNamePattern;
            ScreenShotsList.Add(Range);

            try
              MakeAllScreenShots;
            except
              on E: EInvalidScreenShotFileName do
                MessageOk(Glwin, 'Making screenshot failed: ' +NL+NL+ E.Message, taLeft);
            end;

            ScreenShotsList.FreeContents;
          end;
  end;

  procedure PrecalculateAnimationFromVRMLEvents;
  var
    ScenesPerTime: Cardinal;
    TimeBegin, TimeEnd: Single;
    RootNode: TVRMLNode;
  const
    EqualityEpsilon = 0.0001;
  begin
    if SceneAnimation.ScenesCount <> 1 then
    begin
      MessageOK(Glwin, 'This is not possible when you already have a precalculated animation (like loaded from Kanim or MD3 file).', taLeft);
      Exit;
    end;

    TimeBegin := 0;
    TimeEnd := 10;
    ScenesPerTime := 25;

    if MessageInputQuery(Glwin, 'This will "record" an interactive animation (done by VRML events, interpolators, sensors etc.) into a non-interactive precalculated animation. This allows an animation to be played ultra-fast, although may also be memory-consuming for long ranges of time.' +nl+
         nl+
         'World BEGIN time of recording:', TimeBegin, taLeft) and
       MessageInputQuery(Glwin,
         'World END time of recording:', TimeEnd, taLeft) and
       MessageInputQueryCardinal(Glwin,
         'Scenes per second (higher values make animation smoother but also more memory-consuming):', ScenesPerTime, taLeft) then
    begin
      { Note: there's an inherent problem here since RootNode starts
        with state from current WorldTime. This includes
        TimeDependentNodeHandler state like IsActive, etc., but also
        the rest of VRML graph (e.g. if some events change some geometry
        or materials). While LoadFromVRMLEvents takes care to call
        ResetWorldTime, this only resets time-dependent nodes and routes
        and the like, but it cannot at the same time deactivate-and-then-activate
        time-dependent nodes in the same timestamp (so e.g. TimeSensor just
        remains active, if it was active currently and is determined to be
        active during animation, without a pair of Active.Send(false) +
        Active.Send(true)). And it cannot revert whole VRML graph state.

        This is inherent to the fact that we take current RootNode,
        not the loaded one, so it cannot really be fixed --- we would have
        to just reload RootNode from file, since we cannot keep RootNode
        copy just for this purpose.

        So I just treat it silently as non-fixable in view3dscene,
        you have to load model with ProcessEvents = initially false
        to safely do LoadFromVRMLEvents. }

      { Extract RootNode. OwnsFirstRootNode set to false, to avoid
        freeing it when current animation is closed (which is done implicitly
        at the beginning of LoadFromVRMLEvents). }
      SceneAnimation.OwnsFirstRootNode := false;
      RootNode := SceneAnimation.Scenes[0].RootNode;

      { Using LoadFromVRMLEvents will also Close the previous scene.
        Before doing this, we must always free our octrees
        (as SceneAnimation.FirstScene keeps references to our octrees). }
      SceneOctreeFree;

      { Root node will be owned by LoadFromVRMLEvents, so it will be freed }
      SceneAnimation.LoadFromVRMLEvents(RootNode, true,
        TimeBegin, TimeEnd, ScenesPerTime, EqualityEpsilon,
        'Precalculating animation');

      { Since we just destroyed RootNode, and replaced it with completely
        different scene, we have to recalculate many things.
        Recalculate octree.
        GeometryChanged takes care of invalidating SelectedItem and such. }
      SceneOctreeCreate;
      THelper.GeometryChanged(nil, true);
      THelper.ViewpointsChanged(SceneAnimation.FirstScene);
    end;
  end;

  procedure SelectedShapeOctreeStat;
  var
    SI: TVRMLShapeTreeIterator;
    Shape: TVRMLShape;
  begin
    if SelectedItem = nil then
    begin
      MessageOk(Glwin, 'Nothing selected.', taLeft);
    end else
    begin
      Shape := nil;
      { TODO: 1. this will be wrong when the same geometry node and state
        will be within one TVRMLShape 2. TVRMLTriangle should just
        have a link to Shape. }

      SI := TVRMLShapeTreeIterator.Create(SceneAnimation.FirstScene.Shapes, false);
      try
        while SI.GetNext do
        begin
          Shape := SI.Current;
          if (Shape.Geometry = SelectedItem^.Geometry) and
             (Shape.State = SelectedItem^.State) then
            Break else
            Shape := nil;
        end;
      finally FreeAndNil(SI) end;

      if Shape = nil then
        MessageOk(Glwin, 'Shape not found --- hmmm, this should not happen, report a bug.', taLeft) else
      if Shape.OctreeTriangles = nil then
        MessageOk(Glwin, 'No collision octree was initialized for this shape.', taLeft) else
      begin
        Writeln(Shape.OctreeTriangles.Statistics);
      end;
    end;
  end;

  const
    DefaultCubeMapSize = 256;

  procedure ScreenShotToCubeMap;
  var
    Side: TCubeMapSide;
    CubeMapImg: TCubeMapImages;
    FileNamePattern: string;
    Orientation: char;
    Size: Cardinal;
  begin
    Orientation := MessageChar(Glwin,
      'This function will save six separate image files that show cube map environment around you.' + NL +
      NL +
      'In a moment you will be asked to choose directory and base filename for saving these images, right now you have to decide how the cube map faces will be oriented and named. ("Names" of cube map faces will be placed instead of "%s" in image file pattern.)' + NL +
      NL +
      '[B] : VRML/X3D Background orientation (left/right/...)' + NL +
      '[O] : OpenGL orientation (positive/negative x/y/z)' + NL +
      '[D] : DirectX (and DDS) orientation (positive/negative x/y/z, in left-handed coord system)' + NL +
      NL +
      '[Escape] Cancel',
      ['b', 'o', 'd', CharEscape],
      'Press [B], [O], [D] or [Escape]',
      taLeft, true);

    if Orientation <> CharEscape then
    begin
      if SceneFileName <> '' then
        FileNamePattern := ExtractOnlyFileName(SceneFileName) + '_cubemap_%s.png' else
        FileNamePattern := 'view3dscene_cubemap_%s.png';

      if Glwin.FileDialog('Image name template to save', FileNamePattern, false) then
      begin
        Size := DefaultCubeMapSize;

        if MessageInputQueryCardinal(Glwin, 'Size of cube map images', Size, taLeft) then
        begin
          for Side := Low(Side) to High(Side) do
            CubeMapImg[Side] := TRGBImage.Create(Size, Size);

          GLCaptureCubeMapImages(CubeMapImg, WalkNav.CameraPos, @Draw3d,
            SceneAnimation.WalkProjectionNear, SceneAnimation.WalkProjectionFar,
            true, 0, 0);
          glViewport(0, 0, Glwin.Width, Glwin.Height);

          case Orientation of
            'b':
              begin
                CubeMapImg[csPositiveX].Rotate(2);
                CubeMapImg[csNegativeX].Rotate(2);
                CubeMapImg[csPositiveZ].Rotate(2);
                CubeMapImg[csNegativeZ].Rotate(2);
                SaveImage(CubeMapImg[csPositiveX], Format(FileNamePattern, ['right']));
                SaveImage(CubeMapImg[csNegativeX], Format(FileNamePattern, ['left']));
                SaveImage(CubeMapImg[csPositiveY], Format(FileNamePattern, ['top']));
                SaveImage(CubeMapImg[csNegativeY], Format(FileNamePattern, ['bottom']));
                SaveImage(CubeMapImg[csPositiveZ], Format(FileNamePattern, ['back']));
                SaveImage(CubeMapImg[csNegativeZ], Format(FileNamePattern, ['front']));
              end;
            'o':
              begin
                { This is the most natural Orientation,
                  our csXxx names match OpenGL names and orientation. }
                SaveImage(CubeMapImg[csPositiveX], Format(FileNamePattern, ['positive_x']));
                SaveImage(CubeMapImg[csNegativeX], Format(FileNamePattern, ['negative_x']));
                SaveImage(CubeMapImg[csPositiveY], Format(FileNamePattern, ['positive_y']));
                SaveImage(CubeMapImg[csNegativeY], Format(FileNamePattern, ['negative_y']));
                SaveImage(CubeMapImg[csPositiveZ], Format(FileNamePattern, ['positive_z']));
                SaveImage(CubeMapImg[csNegativeZ], Format(FileNamePattern, ['negative_z']));
              end;
            'd':
              begin
                { Swap positive/negative y, since DirectX is left-handed. }
                SaveImage(CubeMapImg[csPositiveX], Format(FileNamePattern, ['positive_x']));
                SaveImage(CubeMapImg[csNegativeX], Format(FileNamePattern, ['negative_x']));
                SaveImage(CubeMapImg[csNegativeY], Format(FileNamePattern, ['positive_y']));
                SaveImage(CubeMapImg[csPositiveY], Format(FileNamePattern, ['negative_y']));
                SaveImage(CubeMapImg[csPositiveZ], Format(FileNamePattern, ['positive_z']));
                SaveImage(CubeMapImg[csNegativeZ], Format(FileNamePattern, ['negative_z']));
              end;
            else EInternalError.Create('orient?');
          end;

          for Side := Low(Side) to High(Side) do
            FreeAndNil(CubeMapImg[Side]);
        end;
      end;
    end;
  end;

  procedure ScreenShotToCubeMapDDS;
  var
    DDS: TDDSImage;
    FileName: string;
    Size: Cardinal;
  begin
    if SceneFileName <> '' then
      FileName := ExtractOnlyFileName(SceneFileName) + '_cubemap.dds' else
      FileName := 'view3dscene_cubemap.dds';

    if Glwin.FileDialog('Save image to file', FileName, false) then
    begin
      Size := DefaultCubeMapSize;

      if MessageInputQueryCardinal(Glwin, 'Size of cube map images', Size, taLeft) then
      begin
        DDS := GLCaptureCubeMapDDS(Size, WalkNav.CameraPos, @Draw3d,
          SceneAnimation.WalkProjectionNear, SceneAnimation.WalkProjectionFar,
          true, 0, 0);
        try
          glViewport(0, 0, Glwin.Width, Glwin.Height);
          DDS.SaveToFile(FileName);
        finally FreeAndNil(DDS) end;
      end;
    end;
  end;

var
  S, ProposedScreenShotName: string;
begin
 case MenuItem.IntData of
  10: begin
       s := ExtractFilePath(SceneFilename);
       if glwin.FileDialog('Open file', s, true,
         LoadAsVRMLSequence_FileFilters) then
         LoadScene(s, [], 0.0, true);
      end;

  12: Glw.Close;

  15: begin
        { When reopening, then JumpToInitialViewpoint parameter is false.
          In fact, this was the purpose of this JumpToInitialViewpoint
          parameter: to set it to false when reopening, as this makes
          reopening more useful. }
        LoadScene(SceneFileName, [], 0.0, false);
      end;

  20: begin
        if SceneAnimation.ScenesCount > 1 then
          MessageOK(Glwin, 'Warning: this is a precalculated animation (like from Kanim or MD3 file). Saving it as VRML will only save it''s first frame.',
            taLeft);

        { TODO: this filename gen is stupid, it leads to names like
          _2, _2_2, _2_2_2... while it should lead to _2, _3, _4 etc.... }
        if AnsiSameText(ExtractFileExt(SceneFilename), '.wrl') then
          s := AppendToFileName(SceneFilename, '_2') else
          s := ChangeFileExt(SceneFilename, '.wrl');
        if glwin.FileDialog('Save as VRML file', s, false,
          SaveToVRMLFile_FileFilters) then
        try
          SaveToVRMLFile(SceneAnimation.FirstScene.RootNode, s,
            SavedVRMLPrecedingComment(SceneFileName));
        except
          on E: Exception do
          begin
            MessageOK(glw, 'Error while saving scene to "' +S+ '": ' +
              E.Message, taLeft);
          end;
        end;
      end;

  21: ViewSceneWarnings;

  31: ChangeSceneAnimation([scNoNormals], SceneAnimation);
  32: ChangeSceneAnimation([scNoSolidObjects], SceneAnimation);
  33: ChangeSceneAnimation([scNoConvexFaces], SceneAnimation);

  34: RemoveNodesWithMatchingName;
  35: RemoveSpecialCastleNodes;

  36: RemoveSelectedGeometry;
  37: RemoveSelectedFace;

  41: AssignGLSLShader;

  { Before all calls to SetViewpointCore below, we don't really have to
    swith to nkWalk. But user usually wants to switch to nkWalk ---
    in nkExamine viewpoint result is not visible at all. }
  51: begin
        SetNavigatorKind(Glw, nkWalk);
        SetViewpointCore(StdVRMLCamPos[1], StdVRMLCamDir, StdVRMLCamUp, StdVRMLGravityUp);
      end;
  52: begin
        SetNavigatorKind(Glw, nkWalk);
        SetViewpointCore(StdVRMLCamPos[2], StdVRMLCamDir, StdVRMLCamUp, StdVRMLGravityUp);
      end;
  53: begin
        SetNavigatorKind(Glw, nkWalk);
        SetViewpointForWholeScene(1);
      end;
  54: begin
        SetNavigatorKind(Glw, nkWalk);
        SetViewpointForWholeScene(2);
      end;

  82: ShowBBox := not ShowBBox;
  83: with SceneAnimation do Attributes.SmoothShading := not Attributes.SmoothShading;
  84: if glwin.ColorDialog(BGColor) then BGColorChanged;
  85: with SceneAnimation do Attributes.UseFog := not Attributes.UseFog;
  86: with SceneAnimation do Attributes.Blending := not Attributes.Blending;
  87: with SceneAnimation do Attributes.GLSLShaders := not Attributes.GLSLShaders;

  91: LightCalculate := not LightCalculate;
  92: HeadLight := not HeadLight;
  93: with SceneAnimation do Attributes.UseLights := not Attributes.UseLights;
  94: with SceneAnimation do Attributes.EnableTextures := not Attributes.EnableTextures;
  95: ChangeLightModelAmbient;
  96: ShowFrustum := not ShowFrustum;
  180: ShowFrustumAlwaysVisible := not ShowFrustumAlwaysVisible;

  97: begin
        if OctreeDisplayWhole then
        begin
          OctreeDisplayWhole := false;
          MenuOctreeDisplayWhole.Checked := OctreeDisplayWhole;
          OctreeDisplayDepth := -1;
        end;

        Inc(octreeDisplayDepth);
        if (SceneOctreeCollisions <> nil) and
           (octreeDisplayDepth > SceneOctreeCollisions.MaxDepth) then
          octreeDisplayDepth := -1;
      end;

  98: begin
        if OctreeDisplayWhole then
        begin
          OctreeDisplayWhole := false;
          MenuOctreeDisplayWhole.Checked := OctreeDisplayWhole;
          OctreeDisplayDepth := -1;
        end;

        Dec(octreeDisplayDepth);
        if octreeDisplayDepth < -1 then
          if SceneOctreeCollisions <> nil then
            octreeDisplayDepth := SceneOctreeCollisions.MaxDepth else
            octreeDisplayDepth := 0;
      end;

  99: begin
        OctreeDisplayWhole := not OctreeDisplayWhole;
        if not OctreeDisplayWhole then
          OctreeDisplayDepth := -1;
      end;

  100: SelectedShapeOctreeStat;
  101: if SceneOctreeCollisions <> nil then
         Writeln(SceneOctreeCollisions.Statistics) else
         MessageOk(Glwin, SOnlyWhenOctreeAvailable, taLeft);
  103: if SceneOctreeRendering <> nil then
         Writeln(SceneOctreeRendering.Statistics) else
         MessageOk(Glwin, SOnlyWhenOctreeAvailable, taLeft);
  102: SceneAnimation.WritelnInfoNodes;

  105: Writeln(Format(
         'Call rayhunter like this to render this view :' +nl+
         'rayhunter classic %d %d %d "%s" "%s" \' +nl+
         '  --camera-pos %s \' +nl+
         '  --camera-dir %s \' +nl+
         '  --camera-up %s \' +nl+
         '  --view-angle-x %s --scene-bg-color %f %f %f',
         [ DEF_RAYTRACE_DEPTH,
           Glw.Width, Glw.Height,
           SceneFilename,
           ExtractOnlyFileName(SceneFilename) + '-rt.png',
           VectorToRawStr(WalkNav.CameraPos),
           VectorToRawStr(WalkNav.CameraDir),
           VectorToRawStr(WalkNav.CameraUp),
           FloatToStr(AngleOfViewX),
           BGColor[0], BGColor[1], BGColor[2] ]));

  106: WritelnCameraSettings(1);
  107: WritelnCameraSettings(2);

  108: Writeln(
         'Current Walk navigation frustum planes :' +nl+
         '((A, B, C, D) means a plane given by equation A*x + B*y + C*z + D = 0.)' +nl+
         '  Left   : ' + VectorToRawStr(WalkNav.Frustum.Planes[fpLeft]) +nl+
         '  Right  : ' + VectorToRawStr(WalkNav.Frustum.Planes[fpRight]) +nl+
         '  Bottom : ' + VectorToRawStr(WalkNav.Frustum.Planes[fpBottom]) +nl+
         '  Top    : ' + VectorToRawStr(WalkNav.Frustum.Planes[fpTop]) +nl+
         '  Near   : ' + VectorToRawStr(WalkNav.Frustum.Planes[fpNear]) +nl+
         '  Far    : ' + VectorToRawStr(WalkNav.Frustum.Planes[fpFar]));

  109: WriteBoundingBox(SceneAnimation.BoundingBoxSum);
  110: WriteBoundingBox(SceneAnimation.SceneFromTime(AnimationTime).BoundingBox);

  111: ChangeNavigatorKind(glw, +1);

  121: begin
         ShowAndWrite(
           'Scene "' + SceneFilename + '" information:' + NL + NL +
           SceneAnimation.Info(true, true, false));
       end;
  122: ShowStatus := not ShowStatus;
  123: SetCollisionCheck(not CollisionCheck, false);
  124: ChangeGravityUp;
  125: if Glw.Navigator is TWalkNavigator then
       begin
         RaytraceToWin(Glwin, SceneAnimation.FirstScene,
           HeadLight, SceneHeadLight,
           Glw.WalkNav.CameraPos,
           Glw.WalkNav.CameraDir, Glw.WalkNav.CameraUp,
           AngleOfViewX, AngleOfViewY, BGColor,
           SceneAnimation.FirstScene.FogNode,
           SceneAnimation.FirstScene.FogDistanceScaling);
       end else
         MessageOK(Glwin, SOnlyInWalker);
  126: Glw.SwapFullScreen;
  127: begin
         if SceneFileName <> '' then
           ProposedScreenShotName := ExtractOnlyFileName(SceneFileName) + '_%d.png' else
           ProposedScreenShotName := 'view3dscene_screen_%d.png';
         Glwin.SaveScreenDialog(FNameAutoInc(ProposedScreenShotName));
       end;
  128: begin
         WalkNav.MouseLook := not WalkNav.MouseLook;
         Glw.UpdateMouseLook;

         if WalkNav.MouseLook then
         begin
           WalkNav.Input_LeftStrafe.AssignFromDefault(WalkNav.Input_LeftRot);
           WalkNav.Input_RightStrafe.AssignFromDefault(WalkNav.Input_RightRot);
           WalkNav.Input_LeftRot.AssignFromDefault(WalkNav.Input_LeftStrafe);
           WalkNav.Input_RightRot.AssignFromDefault(WalkNav.Input_RightStrafe);
         end else
         begin
           WalkNav.Input_LeftStrafe.MakeDefault;
           WalkNav.Input_RightStrafe.MakeDefault;
           WalkNav.Input_LeftRot.MakeDefault;
           WalkNav.Input_RightRot.MakeDefault;
         end;
       end;

  129: begin
         ShowAndWrite(SceneAnimation.Info(false, false, true));
         SceneAnimation.FreeResources([frManifoldAndBorderEdges]);
       end;

  131: begin
         ShowAndWrite(
           'view3dscene: VRML / X3D browser and full-featured viewer of other 3D models.' +nl+
           'Formats: X3D, VRML 1.0 and 2.0 (aka VRML 97), 3DS, MD3, Wavefront OBJ, Collada.' + NL +
           'Version ' + Version + '.' + NL +
           'By Michalis Kamburelis.' + NL +
           NL +
           '[http://vrmlengine.sourceforge.net/view3dscene.php]' + NL +
           NL +
           'Compiled with ' + SCompilerDescription +'.');
       end;

  171: SelectedShowInformation;
  172: SelectedShowLightsInformation;
  173: ShowAndWrite(GLCapsString);

  182: ChangePointSize;

  201: WalkNav.Gravity := not WalkNav.Gravity;
  202: WalkNav.PreferGravityUpForRotations := not WalkNav.PreferGravityUpForRotations;
  203: WalkNav.PreferGravityUpForMoving := not WalkNav.PreferGravityUpForMoving;
  205: ChangeMoveSpeed;
  210: WalkNav.IgnoreAllInputs := not WalkNav.IgnoreAllInputs;

  220: AnimationTimePlaying := not AnimationTimePlaying;
  221: begin
         AnimationTime := SceneAnimation.TimeBegin;
         WorldTimeAtLoad := 0.0;
         ResetWorldTime(AnimationTime);
       end;
  222: ChangeAnimationTimeSpeed;
  223: ChangeAnimationTimeSpeedWhenLoading;

  225: PrecalculateAnimationFromVRMLEvents;

  300..399:
    begin
      { We could just bind given viewpoint, without swithing to nkWalk.
        But user usually wants to switch to nkWalk --- in nkExamine
        current viewpoint is not visible at all. }
      SetNavigatorKind(Glw, nkWalk);
      ViewpointsList[MenuItem.IntData - 300].EventSet_Bind.
        Send(true, SceneAnimation.FirstScene.WorldTime);
      { Sending set_bind = true works fine if it's not current viewpoint,
        otherwise nothing happens... So just call UpdateViewpointNode
        explicitly, to really reset on the given viewpoint. }
      UpdateViewpointNode;
    end;

  400..419: SceneAnimation.Attributes.BlendingSourceFactor :=
    BlendingFactors[MenuItem.IntData - 400].Value;
  420..439: SceneAnimation.Attributes.BlendingDestinationFactor :=
    BlendingFactors[MenuItem.IntData - 420].Value;

  500..519:
    begin
      SetFillMode(MenuItem.IntData - 500);
      { appropriate Checked will be set automatically }
    end;
  520:
    begin
      SetFillMode((FillMode + 1) mod (High(FillMode) + 1));
      FillModesMenu[FillMode].Checked := true;
    end;

  530: ChangeWireframeWidth;

  540: ScreenShotToVideo;
  550: ScreenShotToCubeMap;
  555: ScreenShotToCubeMapDDS;

  600..649: AntiAliasing := MenuItem.IntData - 600;

  710: ChangeMaterialDiffuse;
  720: ChangeMaterialSpecular;

  740: ShadowsPossibleWanted := not ShadowsPossibleWanted;
  750: ShadowsOn := not ShadowsOn;
  760: DrawShadowVolumes := not DrawShadowVolumes;

  1000..1099: SetColorModulatorType(
    TColorModulatorType(MenuItem.IntData-1000), SceneAnimation);
  1100..1199: SetTextureMinFilter(
    TTextureMinFilter  (MenuItem.IntData-1100), SceneAnimation);
  1200..1299: SetTextureMagFilter(
    TTextureMagFilter  (MenuItem.IntData-1200), SceneAnimation);
  1300..1399: SetNavigatorKind(glw,
    TNavigatorKind(     MenuItem.IntData-1300));
  1400..1499: SceneAnimation.Attributes.BumpMappingMaximum :=
    TBumpMappingMethod( MenuItem.IntData-1400);
  1500..1599:
    begin
      Optimization := TGLRendererOptimization(MenuItem.IntData-1500);
      { This is not needed, as radio items for optimization have AutoCheckedToggle
        OptimizationMenu[Optimization].Checked := true;
      }
      SceneAnimation.Optimization := Optimization;
    end;
  else raise EInternalError.Create('not impl menu item');
 end;

 glwin.PostRedisplay;
end;

function CreateMainMenu: TMenu;

  procedure AppendColorModulators(M: TMenu);
  var
    Cmt: TColorModulatorType;
    Radio: TMenuItemRadio;
    RadioGroup: TMenuItemRadioGroup;
  begin
    RadioGroup := nil;
    for Cmt := Low(Cmt) to High(Cmt) do
    begin
      Radio := TMenuItemRadio.Create(
        SQuoteMenuEntryCaption(ColorModulatorInfos[Cmt].Name),
        Ord(Cmt) + 1000, ColorModulatorType = Cmt, true);
      if RadioGroup = nil then
        RadioGroup := Radio.Group else
        Radio.Group := RadioGroup;
      M.Append(Radio);
    end;
  end;

  procedure AppendNavigationTypes(M: TMenu);
  var
    NavKind: TNavigatorKind;
    Radio: TMenuItemRadio;
    RadioGroup: TMenuItemRadioGroup;
  begin
    RadioGroup := nil;
    for NavKind := Low(NavKind) to High(NavKind) do
    begin
      Radio := TMenuItemRadio.Create(
        SQuoteMenuEntryCaption(NavigatorNames[NavKind]),
        Ord(NavKind) + 1300, NavKind = NavigatorKind, true);
      if RadioGroup = nil then
        RadioGroup := Radio.Group else
        Radio.Group := RadioGroup;
      M.Append(Radio);
      NavigatorRadios[NavKind] := Radio;
    end;
  end;

  procedure AppendBlendingFactors(M: TMenu; Source: boolean;
    BaseIntData: Cardinal);
  var
    Radio: TMenuItemRadio;
    RadioGroup: TMenuItemRadioGroup;
    I: Cardinal;
    Caption: string;
    IsDefault: boolean;
  begin
    RadioGroup := nil;

    for I := Low(BlendingFactors) to High(BlendingFactors) do
      if (Source and BlendingFactors[I].ForSource) or
         ((not Source) and BlendingFactors[I].ForDestination) then
      begin
        if Source then
          IsDefault := BlendingFactors[I].Value = DefaultBlendingSourceFactor else
          IsDefault := BlendingFactors[I].Value = V3DDefaultBlendingDestinationFactor;
        Caption := SQuoteMenuEntryCaption(BlendingFactors[I].Name);
        if IsDefault then
          Caption += ' (default)';
        Radio := TMenuItemRadio.Create(Caption, BaseIntData + I, IsDefault, true);
        if RadioGroup = nil then
          RadioGroup := Radio.Group else
          Radio.Group := RadioGroup;
        M.Append(Radio);
      end;
  end;

  procedure AppendBumpMappingMethods(M: TMenu);
  var
    BM: TBumpMappingMethod;
    Radio: TMenuItemRadio;
    RadioGroup: TMenuItemRadioGroup;
  begin
    RadioGroup := nil;
    for BM := Low(BM) to High(BM) do
    begin
      Radio := TMenuItemRadio.Create(
        SQuoteMenuEntryCaption(BumpMappingMethodNames[BM]),
        Ord(BM) + 1400, BM = DefaultBumpMappingMaximum, true);
      if RadioGroup = nil then
        RadioGroup := Radio.Group else
        Radio.Group := RadioGroup;
      M.Append(Radio);
    end;
  end;

var
  M, M2, M3: TMenu;
  NextRecentMenuItem: TMenuEntry;
begin
 Result := TMenu.Create('Main menu');
 M := TMenu.Create('_File');
   M.Append(TMenuItem.Create('_Open ...',         10, CtrlO));
   MenuReopen := TMenuItem.Create('_Reopen',      15);
   MenuReopen.Enabled := false;
   M.Append(MenuReopen);
   M.Append(TMenuItem.Create('_Save as VRML ...', 20));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('View _Warnings About Current Scene', 21));
   M.Append(TMenuSeparator.Create);
   M2 := TMenu.Create('_Preferences');
     M3 := TMenu.Create('_Anti Aliasing (Restart view3dscene to Apply)');
       MenuAppendAntiAliasing(M3, 600);
       M2.Append(M3);
     M3 := TMenu.Create('_Rendering optimization');
       MenuAppendOptimization(M3, 1500);
       M2.Append(M3);
     M2.Append(TMenuItemChecked.Create('_Shadows Possible (Restart view3dscene to Apply)',
       740, ShadowsPossibleWanted, true));
     M.Append(M2);
   NextRecentMenuItem := TMenuSeparator.Create;
   M.Append(NextRecentMenuItem);
   RecentMenu.NextMenuItem := NextRecentMenuItem;
   M.Append(TMenuItem.Create('_Exit',             12, CharEscape));
   Result.Append(M);
 M := TMenu.Create('_View');
   M2 := TMenu.Create('_Fill Mode');
     MenuAppendFillModes(M2, 500);
     M2.Append(TMenuSeparator.Create);
     M2.Append(TMenuItem.Create('Next _Fill Mode', 520, CtrlF));
     M2.Append(TMenuSeparator.Create);
     M2.Append(TMenuItem.Create('Set Wireframe Line Width ...', 530));
     M.Append(M2);
   M.Append(TMenuItemChecked.Create('Show _Bounding Box',      82, CtrlB,
     ShowBBox, true));
   M.Append(TMenuItemChecked.Create('_Smooth Shading',         83,
     SceneAnimation.Attributes.SmoothShading, true));
   M.Append(TMenuItem.Create('Change Background Color ...',    84));
   M.Append(TMenuItemChecked.Create('_Fog',                    85,
     SceneAnimation.Attributes.UseFog, true));
   M.Append(TMenuItemChecked.Create('Blending',                86,
     SceneAnimation.Attributes.Blending, true));
   M2 := TMenu.Create('Blending Source Factor');
     AppendBlendingFactors(M2, true, 400);
     M.Append(M2);
   M2 := TMenu.Create('Blending Destination Factor');
     AppendBlendingFactors(M2, false, 420);
     M.Append(M2);
   M2 := TMenu.Create('Change Scene Colors');
     AppendColorModulators(M2);
     M.Append(M2);
   M.Append(TMenuItemChecked.Create('_GLSL shaders',          87,
     SceneAnimation.Attributes.GLSLShaders, true));
   M2 := TMenu.Create('Bump mapping');
     AppendBumpMappingMethods(M2);
     M.Append(M2);
   MenuShadowsMenu := TMenu.Create('Shadows');
     MenuShadowsMenu.Enabled := ShadowsPossibleCurrently;
     MenuShadowsMenu.Append(TMenuItemChecked.Create('Use shadows (requires light with kambiShadowsMain)', 750,
       ShadowsOn, true));
     MenuShadowsMenu.Append(TMenuItemChecked.Create('Draw shadow volumes', 760,
       DrawShadowVolumes, true));
     M.Append(MenuShadowsMenu);
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItemChecked.Create(
     '_Lighting Calculate (GL__LIGHTING enabled)',         91, CtrlL,
     LightCalculate, true));
   MenuHeadlight := TMenuItemChecked.Create('_Head Light', 92, CtrlH,
     Headlight, true);
   M.Append(MenuHeadlight);
   M.Append(TMenuItemChecked.Create('Use Scene Lights',    93,
     SceneAnimation.Attributes.UseLights, true));
   M.Append(TMenuItem.Create('Light Global Ambient Color ...',  95));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItemChecked.Create('_Textures',           94, CtrlT,
     SceneAnimation.Attributes.EnableTextures, true));
   M2 := TMenu.Create('Texture Minification Method');
     MenuAppendTextureMinFilters(M2, 1100);
     M.Append(M2);
   M2 := TMenu.Create('Texture Magnification Method');
     MenuAppendTextureMagFilters(M2, 1200);
     M.Append(M2);
   M.Append(TMenuSeparator.Create);
   M2 := TMenu.Create('Frustum visualization');
     M2.Append(TMenuItemChecked.Create('Show Walk frustum in Examine mode', 96,
       ShowFrustum, true));
     M2.Append(TMenuItemChecked.Create('When Showing Frustum, ' +
       'Show it Over All Other Objects (no depth test)', 180,
       ShowFrustumAlwaysVisible, true));
     M.Append(M2);
   M2 := TMenu.Create('Octree visualization');
     MenuOctreeDisplayWhole := TMenuItemChecked.Create('Show Whole Collisions (Triangle) Octrees',
       99, OctreeDisplayWhole, true);
     M2.Append(MenuOctreeDisplayWhole);
     M2.Append(TMenuItem.Create('Show _Upper Level of Collisions (Triangle) Octrees', 97, CtrlU));
     M2.Append(TMenuItem.Create('Show _Lower Level of Collisions (Triangle) Octrees', 98, CtrlD));
     M.Append(M2);
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Set Point Size ...', 182));
   Result.Append(M);
 M := TMenu.Create('_Navigation');
   ViewpointsList.MenuJumpToViewpoint := TMenu.Create('Jump to Viewpoint');
     ViewpointsList.MakeMenuJumpToViewpoint;
     M.Append(ViewpointsList.MenuJumpToViewpoint);
   M2 := TMenu.Create('Navigation Mode');
     AppendNavigationTypes(M2);
     M2.Append(TMenuSeparator.Create);
     M2.Append(TMenuItem.Create('Switch to Next', 111, CtrlN));
     M.Append(M2);
   M2 := TMenu.Create('Walk mode Settings');
     M2.Append(TMenuItemChecked.Create(
       '_Use Mouse Look',                       128, CtrlM,
         WalkNav.MouseLook, true));
     MenuGravity := TMenuItemChecked.Create(
       '_Gravity',                              201, CtrlG,
       WalkNav.Gravity, true);
     M2.Append(MenuGravity);
     MenuPreferGravityUpForRotations := TMenuItemChecked.Create(
       'Rotate with Respect to Stable (Gravity) Camera Up',      202,
       WalkNav.PreferGravityUpForRotations, true);
     M2.Append(MenuPreferGravityUpForRotations);
     MenuPreferGravityUpForMoving := TMenuItemChecked.Create(
       'Move with Respect to Stable (Gravity) Camera Up',          203,
       WalkNav.PreferGravityUpForMoving, true);
     M2.Append(MenuPreferGravityUpForMoving);
     M2.Append(TMenuItem.Create('Change Gravity Up Vector ...',  124));
     M2.Append(TMenuItem.Create('Change Move Speed...', 205));
     M.Append(TMenuSeparator.Create);
     MenuIgnoreAllInputs := TMenuItemChecked.Create(
       'Disable normal navigation (VRML "NONE" navigation)',  210,
       WalkNav.IgnoreAllInputs, true);
     M2.Append(MenuIgnoreAllInputs);
     M.Append(M2);
   MenuCollisionCheck := TMenuItemChecked.Create(
     '_Collision Detection',                   123, CtrlC,
       CollisionCheck, true);
   M.Append(MenuCollisionCheck);
   Result.Append(M);
 M := TMenu.Create('_Animation');
   MenuAnimationTimePlaying := TMenuItemChecked.Create(
     '_Playing / Paused',   220, CtrlP, AnimationTimePlaying, true);
   M.Append(MenuAnimationTimePlaying);
   M.Append(TMenuItem.Create('Rewind to Beginning', 221));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Playing Speed Slower or Faster (on display) ...', 222));
   M.Append(TMenuItem.Create('Playing Speed Slower or Faster (on loading) ...', 223));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Precalculate Animation from VRML Events ...', 225));
   Result.Append(M);
 M := TMenu.Create('_Edit');
   MenuRemoveSelectedGeometry :=
     TMenuItem.Create('Remove _Geometry Node (containing selected triangle)', 36);
   M.Append(MenuRemoveSelectedGeometry);
   MenuRemoveSelectedFace :=
     TMenuItem.Create('Remove _Face (containing selected triangle)', 37);
   M.Append(MenuRemoveSelectedFace);
   M.Append(TMenuSeparator.Create);
   MenuEditMaterial := TMenu.Create('_Edit Material (of node with selected triangle)');
     MenuEditMaterial.Append(TMenuItem.Create('Diffuse Color ...' , 710));
     MenuEditMaterial.Append(TMenuItem.Create('Specular Color ...', 720));
   M.Append(MenuEditMaterial);
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create(
     'Remove VRML Nodes with Name Matching ...', 34));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create(
     'Remove Normals Info from Scene (forces normals to be calculated)',
      31));
   M.Append(TMenuItem.Create('Mark All Shapes as '+
     'non-solid (disables any backface culling)', 32));
   M.Append(TMenuItem.Create('Mark All Faces as '+
     'non-convex (forces faces to be triangulated carefully)', 33));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create(
     'Simply Assign GLSL Shader to All Objects ...', 41));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create(
     'Remove Special Nodes on "The Castle" Level', 35));
   Result.Append(M);
 M := TMenu.Create('_Console');
   M.Append(TMenuItem.Create('Print VRML _Info nodes',        102));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Print Current Camera _Node (VRML 1.0)',   106));
   M.Append(TMenuItem.Create('Print Current Camera Node (VRML 2.0)',    107));
   M.Append(TMenuItem.Create('Print _rayhunter Command-line to Render This View', 105));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Print _Bounding Box (of whole animation)', 109));
   M.Append(TMenuItem.Create('Print Bounding Box (of current _animation frame)', 110));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Print Current Walk _Frustum', 108));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Print Statistics of Top _Collisions Octree (Based on Shapes)', 101));
   MenuSelectedOctreeStat := TMenuItem.Create('Print Statistics of _Collisions Octree Of Selected Shape (Based on Triangles)', 100);
   M.Append(MenuSelectedOctreeStat);
   M.Append(TMenuItem.Create('Print Statistics of Rendering Octree (Based on Shapes)', 103));
   Result.Append(M);
 M := TMenu.Create('_Display');
   M.Append(TMenuItem.Create('_Screenshot to image ...',         127, K_F5));
   M.Append(TMenuItem.Create('Screenshot to video / multiple images ...', 540));
   M.Append(TMenuItem.Create('Screenshot to _cube map (environment around Walk position) ...',  550));
   M.Append(TMenuItem.Create('Screenshot to cube map DDS (environment around Walk position) ...',  555));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('_Raytrace !',                   125, CtrlR));
   M.Append(TMenuItemChecked.Create('_Full Screen',           126, K_F11,
     Glw.FullScreen, true));
   Result.Append(M);
 M := TMenu.Create('_Help');
   M.Append(TMenuItemChecked.Create('Show Status _Text',           122, K_F1,
      ShowStatus, true));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('Scene Information',                  121));
   M.Append(TMenuItem.Create('Manifold Edges Information',         129));
   MenuSelectedInfo :=
     TMenuItem.Create('Selected Object Information',               171);
   M.Append(MenuSelectedInfo);
   MenuSelectedLightsInfo :=
     TMenuItem.Create('Selected Object Lights Information',        172);
   UpdateSelectedEnabled;
   M.Append(MenuSelectedLightsInfo);
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('OpenGL Information',                 173));
   M.Append(TMenuSeparator.Create);
   M.Append(TMenuItem.Create('About view3dscene',                  131));
   Result.Append(M);
end;

{ initializing GL context --------------------------------------------------- }

procedure MultiSamplingOff(Glwin: TGLWindow; const FailureMessage: string);
begin
  AntiAliasing := 0;
  if AntiAliasingMenu[AntiAliasing] <> nil then
    AntiAliasingMenu[AntiAliasing].Checked := true;
  Writeln(FailureMessage);
end;

procedure StencilOff(Glwin: TGLWindow; const FailureMessage: string);
begin
  ShadowsPossibleCurrently := false;
  Writeln(FailureMessage);
end;

{ Call Glw.Init, when anti-aliasing (multi-sampling) and shadows (stencil
  buffer) are possibly allowed. If EGLContextNotPossible, will try to lower
  requirements and initialize worse GL context. }
procedure InitContext;
begin
  Glw.InitOptionalMultiSamplingAndStencil(@MultiSamplingOff, @StencilOff);
end;

{ main --------------------------------------------------------------------- }

var
  Param_CameraRadius: Single = 0.0;
  WasParam_WriteToVRML: boolean = false;

  WasParam_SceneFileName: boolean = false;
  Param_SceneFileName: string;
  Param_SceneChanges: TSceneChanges = [];

const
  Options: array[0..11] of TOption =
  (
    (Short:  #0; Long: 'camera-radius'; Argument: oaRequired),
    (Short:  #0; Long: 'scene-change-no-normals'; Argument: oaNone),
    (Short:  #0; Long: 'scene-change-no-solid-objects'; Argument: oaNone),
    (Short:  #0; Long: 'scene-change-no-convex-faces'; Argument: oaNone),
    (Short:  #0; Long: 'write-to-vrml'; Argument: oaNone),
    (Short: 'h'; Long: 'help'; Argument: oaNone),
    (Short: 'v'; Long: 'version'; Argument: oaNone),
    (Short:  #0; Long: 'screenshot'; Argument: oaRequired2Separate),
    (Short:  #0; Long: 'screenshot-range'; Argument: oaRequired4Separate),
    (Short:  #0; Long: 'debug-log'; Argument: oaNone),
    (Short:  #0; Long: 'debug-log-vrml-changes'; Argument: oaNone),
    (Short:  #0; Long: 'anti-alias'; Argument: oaRequired)
  );

  procedure OptionProc(OptionNum: Integer; HasArgument: boolean;
    const Argument: string; const SeparateArgs: TSeparateArgs; Data: Pointer);
  var
    SingleScreenShot: TSingleScreenShot;
    RangeScreenShot: TRangeScreenShot;
  begin
   case OptionNum of
    0 : Param_CameraRadius := StrToFloat(Argument);
    1 : Include(Param_SceneChanges, scNoNormals);
    2 : Include(Param_SceneChanges, scNoSolidObjects);
    3 : Include(Param_SceneChanges, scNoConvexFaces);
    4 : WasParam_WriteToVRML := true;
    5 : begin
         InfoWrite(
           'view3dscene: VRML (1.0 and 2.0, aka VRML 97), Kanim,' +NL+
           '3DS, MD3, Wavefront OBJ and Collada viewer.' +NL+
           'You can move in the scene, possibly with collision-checking.' +NL+
           'It can also be used to convert models in other formats (3DS etc.) to VRML.' +NL+
           'It has built-in raytracer, similar to that available in "rayhunter".' +NL+
           NL+
           'Call as' +NL+
           '  view3dscene [OPTIONS]... FILE-TO-VIEW' +NL+
           NL+
           'Available options are:' +NL+
           HelpOptionHelp +NL+
           VersionOptionHelp +NL+
           '  --camera-radius RADIUS' +NL+
           '                        Set camera sphere radius used for collisions' +NL+
           '                        and determinig moving speed' +NL+
           '  --scene-change-no-normals ,' +NL+
           '  --scene-change-no-solid-objects ,' +NL+
           '  --scene-change-no-convex-faces' +NL+
           '                        Change scene somehow after loading' +NL+
           '  --write-to-vrml       After loading (and changing) scene, write it' +NL+
           '                        as VRML 1.0 to the standard output' +NL+
           MultiNavigatorsOptionsHelp +NL+
           LightsOptionsHelp +NL+
           VRMLNodesDetailOptionsHelp +NL+
           RendererOptimizationOptionsHelp +NL+
           '  --screenshot TIME IMAGE-FILE-NAME' +NL+
           '                        Take a screenshot of the loaded scene' +NL+
           '                        at given TIME, and save it to IMAGE-FILE-NAME.' +NL+
           '                        You most definitely want to pass 3D model' +NL+
           '                        file to load at command-line too, otherwise' +NL+
           '                        we''ll just make a screenshot of the default' +NL+
           '                        black scene.' +NL+
           '  --screenshot-range TIME-BEGIN TIME-STEP FRAMES-COUNT FILE-NAME' +NL+
           '                        Take a FRAMES-COUNT number of screenshots from' +NL+
           '                        TIME-BEGIN by step TIME-STEP. Save them to' +NL+
           '                        a single movie file (like .avi) (ffmpeg must' +NL+
           '                        be installed and available on $PATH for this)' +NL+
           '                        or to a sequence of image files (FILE-NAME' +NL+
           '                        must then be specified like image%d.png).' +NL+
           '  --anti-alias AMOUNT   Use full-screen anti-aliasing.' +NL+
           '                        Argument AMOUNT is an integer >= 0.' +NL+
           '                        Exact 0 means "no anti-aliasing",' +NL+
           '                        this is the default. Each successive integer' +NL+
           '                        generally makes method one step better.' +NL+
           NL+
           TGLWindow.ParseParametersHelp(StandardParseOptions, true) +NL+
           NL+
           'Debug options:' +NL+
           '  --debug-log           Write log info to stdout.' +NL+
           '  --debug-log-vrml-changes' +nl+
           '                        If --debug-log, output also info about' +NL+
           '                        VRML graph changes. This indicates' +nl+
           '                        how VRML events are optimized.' +nl+
           NL+
           SVrmlEngineProgramHelpSuffix(DisplayProgramName, Version, true));
         ProgramBreak;
        end;
    6 : begin
         Writeln(Version);
         ProgramBreak;
        end;
    7 : begin
          SingleScreenShot := TSingleScreenShot.Create;
          SingleScreenShot.Time := StrToFloat(SeparateArgs[1]);
          SingleScreenShot.FileNamePattern := SeparateArgs[2];
          ScreenShotsList.Add(SingleScreenShot);
        end;
    8 : begin
          RangeScreenShot := TRangeScreenShot.Create;
          RangeScreenShot.TimeBegin := StrToFloat(SeparateArgs[1]);
          RangeScreenShot.TimeStep := StrToFloat(SeparateArgs[2]);
          RangeScreenShot.FramesCount := StrToInt(SeparateArgs[3]);
          RangeScreenShot.FileNamePattern := SeparateArgs[4];
          ScreenShotsList.Add(RangeScreenShot);
        end;
    9 : InitializeLog(Version);
    10: begin
          InitializeLog(Version);
          DebugLogVRMLChanges := true;
        end;
    11: begin
          { for proper menu display, we have to keep AntiAliasing
            within 0..MaxAntiAliasing range (although GLAntiAliasing
            unit accepts any cardinal value). }
          AntiAliasing := Clamped(StrToInt(Argument), 0, MaxAntiAliasing);
          if AntiAliasingMenu[AntiAliasing] <> nil then
            AntiAliasingMenu[AntiAliasing].Checked := true;
        end;
    else raise EInternalError.Create('OptionProc');
   end;
  end;

begin
  { parse parameters }
  { glw params }
  Glw.ParseParameters(StandardParseOptions);
  { our params }
  MultiNavigatorsParseParameters;
  LightsParseParameters;
  VRMLNodesDetailOptionsParse;
  RendererOptimizationOptionsParse(Optimization);
  ParseParameters(Options, @OptionProc, nil);
  { the most important param : filename to load }
  if Parameters.High > 1 then
   raise EInvalidParams.Create('Excessive command-line parameters. '+
     'Expected at most one filename to load') else
  if Parameters.High = 1 then
  begin
    WasParam_SceneFileName := true;
    Param_SceneFileName := Parameters[1];
  end;

  if ScreenShotsList.Count = 1 then
  begin
    { There's no point in using better optimization. They would waste
      time to prepare display lists, while we only render scene once. }
    Optimization := roNone;
    OptimizationSaveConfig := false;
  end;

  SceneWarnings := TSceneWarnings.Create;
  try
    VRMLWarning := @DoVRMLWarning;
    DataWarning := @DoDataWarning;

    if WasParam_WriteToVRML then
    begin
      if not WasParam_SceneFileName then
        raise EInvalidParams.Create('You used --write-to-vrml option, '+
          'this means that you want to convert some 3d model file to VRML. ' +
          'But you didn''t provide any filename on command-line to load.');
      WriteToVRML(Param_SceneFileName, Param_SceneChanges);
      Exit;
    end;

    { This is for loading default clean scene.
      LoadClearScene should be lighting fast always,
      so progress should not be needed in this case anyway
      (and we don't want to clutter stdout). }
    Progress.UserInterface := ProgressNullInterface;

    InitMultiNavigators(glw, @Helper.MoveAllowed, @Helper.GetCameraHeight,
      @Helper.WalkerMatrixChanged);

    { init "scene global variables" to null values }
    SceneAnimation := TVRMLGLAnimation.Create;
    try
      { in view3dscene SceneAnimation.Attributes.UseLights default value is true }
      SceneAnimation.Optimization := Optimization;
      SceneAnimation.Attributes.UseLights := true;
      SceneAnimation.Attributes.BlendingDestinationFactor := V3DDefaultBlendingDestinationFactor;
      InitColorModulator(SceneAnimation);
      InitTextureFilters(SceneAnimation);

      RecentMenu := TGLRecentMenu.Create;
      RecentMenu.LoadFromConfig(ConfigFile, 'recent_files');
      RecentMenu.OnOpenRecent := @Helper.OpenRecent;

      { init "scene global variables" to non-null values }
      LoadClearScene;
      try
        GLWinMessagesTheme := GLWinMessagesTheme_TypicalGUI;

        Glw.GtkIconName := 'view3dscene';
        Glw.MainMenu := CreateMainMenu;
        Glw.OnMenuCommand := @MenuCommand;
        Glw.OnResize := @Resize;
        Glw.OnInit := @Init;
        Glw.OnClose := @Close;
        Glw.OnMouseDown := @MouseDown;
        Glw.OnMouseUp := @MouseUp;
        Glw.OnMouseMove := @MouseMove;
        Glw.OnIdle := @Idle;
        Glw.OnKeyDown := @KeyDown;
        Glw.OnKeyUp := @KeyUp;

        { For the screenshot, leave BeforeDraw and Draw as @nil,
          we'll want to call them manually later to have control
          over them. }
        if not MakingScreenShot then
        begin
          Glw.OnBeforeDraw := @BeforeDraw;
          Glw.OnDraw := @Draw;
        end else
        begin
          { --geometry must work as reliably as possible in this case. }
          Glw.ResizeAllowed := raNotAllowed;

          { Do not show window on the screen, since we're working in batch mode. }
          Glw.WindowVisible := false;
        end;

        Glw.SetDemoOptions(K_None, #0, true);

        if ShadowsPossibleWanted then
        begin
          Glw.StencilBufferBits := 8;
          { Assignment below essentially copies
            ShadowsPossibleWanted to ShadowsPossibleCurrently.
            ShadowsPossibleCurrently may be eventually turned to @false
            by InitContext. }
          ShadowsPossibleCurrently := true;
        end;
        Assert(ShadowsPossibleCurrently = ShadowsPossibleWanted);

        Glw.MultiSampling := AntiAliasingGlwMultiSampling;

        InitContext;

        if WasParam_SceneFileName then
          LoadScene(Param_SceneFileName, Param_SceneChanges, Param_CameraRadius, true) else
          LoadWelcomeScene;

        if MakingScreenShot then
        begin
          MakeAllScreenShots;
          Exit;
        end;

        Glwm.Loop;
      finally FreeScene end;
    finally
      FreeAndNil(SceneAnimation);
      if RecentMenu <> nil then
        RecentMenu.SaveToConfig(ConfigFile, 'recent_files');
      FreeAndNil(RecentMenu);
    end;
  finally FreeAndNil(SceneWarnings); end;
end.

{
  Local Variables:
  kam-compile-release-command-unix:    "./compile.sh && mv -fv view3dscene      ~/bin/"
  kam-compile-release-command-windows: "./compile.sh && mv -fv view3dscene.exe c:\\\\bin\\\\"
  End:
}
